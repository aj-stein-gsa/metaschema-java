<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSTPrinter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.cst</a> &gt; <span class="el_source">CSTPrinter.java</span></div><h1>CSTPrinter.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.cst;

import gov.nist.secauto.metaschema.core.metapath.cst.comparison.GeneralComparison;
import gov.nist.secauto.metaschema.core.metapath.cst.comparison.ValueComparison;
import gov.nist.secauto.metaschema.core.metapath.cst.math.Addition;
import gov.nist.secauto.metaschema.core.metapath.cst.math.Division;
import gov.nist.secauto.metaschema.core.metapath.cst.math.IntegerDivision;
import gov.nist.secauto.metaschema.core.metapath.cst.math.Modulo;
import gov.nist.secauto.metaschema.core.metapath.cst.math.Multiplication;
import gov.nist.secauto.metaschema.core.metapath.cst.math.Subtraction;
import gov.nist.secauto.metaschema.core.metapath.cst.path.Axis;
import gov.nist.secauto.metaschema.core.metapath.cst.path.ContextItem;
import gov.nist.secauto.metaschema.core.metapath.cst.path.Flag;
import gov.nist.secauto.metaschema.core.metapath.cst.path.ModelInstance;
import gov.nist.secauto.metaschema.core.metapath.cst.path.NameTest;
import gov.nist.secauto.metaschema.core.metapath.cst.path.RelativeDoubleSlashPath;
import gov.nist.secauto.metaschema.core.metapath.cst.path.RelativeSlashPath;
import gov.nist.secauto.metaschema.core.metapath.cst.path.RootDoubleSlashPath;
import gov.nist.secauto.metaschema.core.metapath.cst.path.RootSlashOnlyPath;
import gov.nist.secauto.metaschema.core.metapath.cst.path.RootSlashPath;
import gov.nist.secauto.metaschema.core.metapath.cst.path.Step;
import gov.nist.secauto.metaschema.core.metapath.cst.path.Wildcard;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public final class CSTPrinter {
  private CSTPrinter() {
    // disable construction
  }

  /**
   * Generate a string representation of the CST tree.
   *
   * @param expr
   *          an expression that is a branch in the tree to visualize.
   * @return a string representation of the CST graph
   */
  public static String toString(@NonNull IExpression expr) {
<span class="fc" id="L46">    return new CSTPrinterVisitor().visit(expr);</span>
  }

  @SuppressWarnings(&quot;PMD.ExcessivePublicCount&quot;)
  private static final class CSTPrinterVisitor
      extends AbstractExpressionVisitor&lt;String, State&gt; {

    @Override
    protected String visitChildren(IExpression expr, State context) {
<span class="fc" id="L55">      context.push();</span>
<span class="fc" id="L56">      String result = super.visitChildren(expr, context);</span>
<span class="fc" id="L57">      context.pop();</span>
<span class="fc" id="L58">      return result;</span>
    }

    @Override
    protected String aggregateResult(String result, String nextResult, State context) {
<span class="fc" id="L63">      StringBuilder buffer = new StringBuilder();</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">      if (result != null) {</span>
<span class="fc" id="L65">        buffer.append(result);</span>
        // buffer.append(&quot; ar &quot;+System.lineSeparator());
      }

<span class="fc" id="L69">      buffer.append(context.getIndentation())</span>
<span class="fc" id="L70">          .append(nextResult);</span>
<span class="fc" id="L71">      return buffer.toString();</span>
    }

    @Override
    protected String defaultResult() {
<span class="fc" id="L76">      return &quot;&quot;;</span>
    }

    /**
     * Append the {@code childResult} to the record produced for the current node.
     *
     * @param expr
     *          the current node
     * @param childResult
     *          the output generated for the curren't node's children
     * @param context
     *          the output context state
     * @return the string representation of the node tree for the current node and
     *         its children
     */
    @SuppressWarnings(&quot;static-method&quot;)
    protected String appendNode(@NonNull IExpression expr, @Nullable String childResult, @NonNull State context) {
<span class="fc" id="L93">      StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L94">      buffer.append(context.getIndentation())</span>
<span class="fc" id="L95">          .append(expr.toASTString());</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">      if (childResult != null) {</span>
<span class="fc" id="L97">        buffer.append(System.lineSeparator())</span>
<span class="fc" id="L98">            .append(childResult);</span>
      }
<span class="fc" id="L100">      return buffer.toString();</span>
    }

    /**
     * Visit a node and produce a string representation of its the node tree.
     *
     * @param expression
     *          the node to build the node tree for
     * @return the string representation of the node tree for the provided
     *         expression node and its children
     */
    public String visit(@NonNull IExpression expression) {
<span class="fc" id="L112">      return visit(expression, new State());</span>
    }

    @Override
    public String visitAddition(Addition expr, State context) {
<span class="fc" id="L117">      return appendNode(expr, super.visitAddition(expr, context), context);</span>
    }

    @Override
    public String visitAnd(And expr, State context) {
<span class="nc" id="L122">      return appendNode(expr, super.visitAnd(expr, context), context);</span>
    }

    @Override
    public String visitStep(Step expr, State context) {
<span class="nc" id="L127">      return appendNode(expr, super.visitStep(expr, context), context);</span>
    }

    @Override
    public String visitValueComparison(ValueComparison expr, State context) {
<span class="nc" id="L132">      return appendNode(expr, super.visitValueComparison(expr, context), context);</span>
    }

    @Override
    public String visitGeneralComparison(GeneralComparison expr, State context) {
<span class="fc" id="L137">      return appendNode(expr, super.visitGeneralComparison(expr, context), context);</span>
    }

    @Override
    public String visitContextItem(ContextItem expr, State context) {
<span class="nc" id="L142">      return appendNode(expr, super.visitContextItem(expr, context), context);</span>
    }

    @Override
    public String visitDecimalLiteral(DecimalLiteral expr, State context) {
<span class="nc" id="L147">      return appendNode(expr, super.visitDecimalLiteral(expr, context), context);</span>
    }

    @Override
    public String visitDivision(Division expr, State context) {
<span class="nc" id="L152">      return appendNode(expr, super.visitDivision(expr, context), context);</span>
    }

    @Override
    public String visitExcept(@NonNull Except expr, State context) {
<span class="nc" id="L157">      return appendNode(expr, super.visitExcept(expr, context), context);</span>
    }

    @Override
    public String visitFlag(Flag expr, State context) {
<span class="nc" id="L162">      return appendNode(expr, super.visitFlag(expr, context), context);</span>
    }

    @Override
    public String visitFunctionCall(StaticFunctionCall expr, State context) {
<span class="nc" id="L167">      return appendNode(expr, super.visitFunctionCall(expr, context), context);</span>
    }

    @Override
    public String visitIntegerDivision(IntegerDivision expr, State context) {
<span class="nc" id="L172">      return appendNode(expr, super.visitIntegerDivision(expr, context), context);</span>
    }

    @Override
    public String visitIntegerLiteral(IntegerLiteral expr, State context) {
<span class="fc" id="L177">      return appendNode(expr, super.visitIntegerLiteral(expr, context), context);</span>
    }

    @Override
    public String visitIntersect(Intersect expr, State context) {
<span class="nc" id="L182">      return appendNode(expr, super.visitIntersect(expr, context), context);</span>
    }

    @Override
    public String visitMetapath(Metapath expr, State context) {
<span class="fc" id="L187">      return appendNode(expr, super.visitMetapath(expr, context), context);</span>
    }

    @Override
    public String visitModulo(Modulo expr, State context) {
<span class="nc" id="L192">      return appendNode(expr, super.visitModulo(expr, context), context);</span>
    }

    @Override
    public String visitModelInstance(ModelInstance expr, State context) {
<span class="nc" id="L197">      return appendNode(expr, super.visitModelInstance(expr, context), context);</span>
    }

    @Override
    public String visitMultiplication(Multiplication expr, State context) {
<span class="nc" id="L202">      return appendNode(expr, super.visitMultiplication(expr, context), context);</span>
    }

    @Override
    public String visitName(NameTest expr, State context) {
<span class="nc" id="L207">      return appendNode(expr, super.visitName(expr, context), context);</span>
    }

    @Override
    public String visitNegate(Negate expr, State context) {
<span class="nc" id="L212">      return appendNode(expr, super.visitNegate(expr, context), context);</span>
    }

    @Override
    public String visitOr(Or expr, State context) {
<span class="nc" id="L217">      return appendNode(expr, super.visitOr(expr, context), context);</span>
    }

    @Override
    public String visitAxis(Axis expr, State context) {
<span class="nc" id="L222">      return appendNode(expr, super.visitAxis(expr, context), context);</span>
    }

    @Override
    public String visitPredicate(PredicateExpression expr, State context) {
<span class="nc" id="L227">      return appendNode(expr, super.visitPredicate(expr, context), context);</span>
    }

    @Override
    public String visitRelativeDoubleSlashPath(RelativeDoubleSlashPath expr, State context) {
<span class="nc" id="L232">      return appendNode(expr, super.visitRelativeDoubleSlashPath(expr, context), context);</span>
    }

    @Override
    public String visitRelativeSlashPath(RelativeSlashPath expr, State context) {
<span class="nc" id="L237">      return appendNode(expr, super.visitRelativeSlashPath(expr, context), context);</span>
    }

    @Override
    public String visitRootDoubleSlashPath(RootDoubleSlashPath expr, State context) {
<span class="nc" id="L242">      return appendNode(expr, super.visitRootDoubleSlashPath(expr, context), context);</span>
    }

    @Override
    public String visitRootSlashOnlyPath(RootSlashOnlyPath expr, State context) {
<span class="nc" id="L247">      return appendNode(expr, super.visitRootSlashOnlyPath(expr, context), context);</span>
    }

    @Override
    public String visitRootSlashPath(RootSlashPath expr, State context) {
<span class="nc" id="L252">      return appendNode(expr, super.visitRootSlashPath(expr, context), context);</span>
    }

    @Override
    public String visitStringConcat(StringConcat expr, State context) {
<span class="nc" id="L257">      return appendNode(expr, super.visitStringConcat(expr, context), context);</span>
    }

    @Override
    public String visitStringLiteral(StringLiteral expr, State context) {
<span class="nc" id="L262">      return appendNode(expr, super.visitStringLiteral(expr, context), context);</span>
    }

    @Override
    public String visitSubtraction(Subtraction expr, State context) {
<span class="nc" id="L267">      return appendNode(expr, super.visitSubtraction(expr, context), context);</span>
    }

    @Override
    public String visitUnion(Union expr, State context) {
<span class="nc" id="L272">      return appendNode(expr, super.visitUnion(expr, context), context);</span>
    }

    @Override
    public String visitWildcard(Wildcard expr, State context) {
<span class="nc" id="L277">      return appendNode(expr, super.visitWildcard(expr, context), context);</span>
    }

    @Override
    public String visitLet(Let expr, State context) {
<span class="nc" id="L282">      return appendNode(expr, super.visitLet(expr, context), context);</span>
    }

    @Override
    public String visitVariableReference(VariableReference expr, State context) {
<span class="fc" id="L287">      return appendNode(expr, super.visitVariableReference(expr, context), context);</span>
    }

    @Override
    public String visitEmptySequence(EmptySequence&lt;?&gt; expr, State context) {
<span class="nc" id="L292">      return appendNode(expr, super.visitEmptySequence(expr, context), context);</span>
    }

    @Override
    public String visitRange(Range expr, State context) {
<span class="nc" id="L297">      return appendNode(expr, super.visitRange(expr, context), context);</span>
    }

    @Override
    public String visitIf(If expr, State context) {
<span class="nc" id="L302">      return appendNode(expr, super.visitIf(expr, context), context);</span>
    }

    @Override
    public String visitQuantified(Quantified expr, State context) {
<span class="fc" id="L307">      return appendNode(expr, super.visitQuantified(expr, context), context);</span>
    }

    @Override
    public String visitFor(For expr, State context) {
<span class="nc" id="L312">      return appendNode(expr, super.visitFor(expr, context), context);</span>
    }

    @Override
    public String visitSimpleMap(SimpleMap expr, State context) {
<span class="nc" id="L317">      return appendNode(expr, super.visitSimpleMap(expr, context), context);</span>
    }

    @Override
    public String visitArray(ArraySequenceConstructor expr, State context) {
<span class="nc" id="L322">      return appendNode(expr, super.visitArray(expr, context), context);</span>
    }

    @Override
    public String visitArray(ArraySquareConstructor expr, State context) {
<span class="nc" id="L327">      return appendNode(expr, super.visitArray(expr, context), context);</span>
    }

    @Override
    public String visitPostfixLookup(PostfixLookup expr, State context) {
<span class="nc" id="L332">      return appendNode(expr, super.visitPostfixLookup(expr, context), context);</span>
    }

    @Override
    public String visitFunctionCallAccessor(FunctionCallAccessor expr, State context) {
<span class="nc" id="L337">      return appendNode(expr, super.visitFunctionCallAccessor(expr, context), context);</span>
    }

    @Override
    public String visitUnaryLookup(UnaryLookup expr, State context) {
<span class="nc" id="L342">      return appendNode(expr, super.visitUnaryLookup(expr, context), context);</span>
    }

    @Override
    public String visitMapConstructor(MapConstructor expr, State context) {
<span class="nc" id="L347">      return appendNode(expr, super.visitMapConstructor(expr, context), context);</span>
    }

    @Override
    public String visitMapConstructorEntry(MapConstructor.Entry expr, State context) {
<span class="nc" id="L352">      return appendNode(expr, super.visitMapConstructorEntry(expr, context), context);</span>
    }
  }

<span class="fc" id="L356">  static class State {</span>
    private int indentation; // 0;
    private int lastIndentation; // 0;
<span class="fc" id="L359">    private String indentationPadding = &quot;&quot;;</span>

    public String getIndentation() {
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (indentation != lastIndentation) {</span>
<span class="fc" id="L363">        StringBuilder buffer = new StringBuilder();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int i = 0; i &lt; indentation; i++) {</span>
<span class="fc" id="L365">          buffer.append(&quot;  &quot;);</span>
        }
<span class="fc" id="L367">        lastIndentation = indentation;</span>
<span class="fc" id="L368">        indentationPadding = buffer.toString();</span>
      }
<span class="fc" id="L370">      return indentationPadding;</span>
    }

    public State push() {
<span class="fc" id="L374">      indentation++;</span>
<span class="fc" id="L375">      return this;</span>
    }

    public State pop() {
<span class="fc" id="L379">      indentation--;</span>
<span class="fc" id="L380">      return this;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>