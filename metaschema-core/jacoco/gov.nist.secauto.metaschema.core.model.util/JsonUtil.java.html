<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.util</a> &gt; <span class="el_source">JsonUtil.java</span></div><h1>JsonUtil.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.util;

import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import gov.nist.secauto.metaschema.core.util.CustomCollectors;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

public final class JsonUtil {
<span class="nc" id="L31">  private static final Logger LOGGER = LogManager.getLogger(JsonUtil.class);</span>

  private JsonUtil() {
    // disable construction
  }

  /**
   * Parse the input stream into a JSON object.
   *
   * @param is
   *          the input stream to parse
   * @return the JSON object
   */
  @NonNull
  public static JSONObject toJsonObject(@NonNull InputStream is) {
<span class="nc" id="L46">    return new JSONObject(new JSONTokener(is));</span>
  }

  /**
   * Parse the reader into a JSON object.
   *
   * @param reader
   *          the reader to parse
   * @return the JSON object
   */
  @NonNull
  public static JSONObject toJsonObject(@NonNull Reader reader) {
<span class="nc" id="L58">    return new JSONObject(new JSONTokener(reader));</span>
  }

  /**
   * Generate an informational string describing the token at the current location
   * of the provided {@code parser}.
   *
   * @param parser
   *          the JSON parser
   * @return the informational string
   * @throws IOException
   *           if an error occurred while getting the information from the parser
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static String toString(@NonNull JsonParser parser) throws IOException {
<span class="nc" id="L74">    return new StringBuilder(32)</span>
<span class="nc" id="L75">        .append(parser.currentToken().name())</span>
<span class="nc" id="L76">        .append(&quot; '&quot;)</span>
<span class="nc" id="L77">        .append(parser.getText())</span>
<span class="nc" id="L78">        .append('\'')</span>
<span class="nc" id="L79">        .append(generateLocationMessage(parser))</span>
<span class="nc" id="L80">        .toString();</span>
  }

  /**
   * Generate an informational string describing the provided {@code location}.
   *
   * @param location
   *          a JSON parser location
   * @return the informational string
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static String toString(@NonNull JsonLocation location) {
<span class="nc" id="L93">    return new StringBuilder(8)</span>
<span class="nc" id="L94">        .append(location.getLineNr())</span>
<span class="nc" id="L95">        .append(':')</span>
<span class="nc" id="L96">        .append(location.getColumnNr())</span>
<span class="nc" id="L97">        .toString();</span>
  }

  /**
   * Advance the parser to the next location matching the provided token.
   *
   * @param parser
   *          the JSON parser
   * @param token
   *          the expected token
   * @return the current token or {@code null} if no tokens remain in the stream
   * @throws IOException
   *           if an error occurred while parsing the JSON
   */
  @Nullable
  public static JsonToken advanceTo(@NonNull JsonParser parser, @NonNull JsonToken token) throws IOException {
<span class="nc" id="L113">    JsonToken currentToken = null;</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">    while (parser.hasCurrentToken() &amp;&amp; !token.equals(currentToken = parser.currentToken())) {</span>
<span class="nc" id="L115">      currentToken = parser.nextToken();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">      if (LOGGER.isWarnEnabled()) {</span>
<span class="nc" id="L117">        LOGGER.warn(&quot;skipping over: {}{}&quot;,</span>
<span class="nc" id="L118">            toString(parser),</span>
<span class="nc" id="L119">            generateLocationMessage(parser));</span>
      }
    }
<span class="nc" id="L122">    return currentToken;</span>
  }

  /**
   * Skip the next JSON value in the stream.
   *
   * @param parser
   *          the JSON parser
   * @return the current token or {@code null} if no tokens remain in the stream
   * @throws IOException
   *           if an error occurred while parsing the JSON
   */
  @SuppressWarnings({
      &quot;resource&quot;, // parser not owned
      &quot;PMD.CyclomaticComplexity&quot; // acceptable
  })
  @Nullable
  public static JsonToken skipNextValue(@NonNull JsonParser parser) throws IOException {

<span class="nc" id="L141">    JsonToken currentToken = parser.currentToken();</span>
    // skip the field name
<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (JsonToken.FIELD_NAME.equals(currentToken)) {</span>
<span class="nc" id="L144">      currentToken = parser.nextToken();</span>
    }

<span class="nc bnc" id="L147" title="All 3 branches missed.">    switch (currentToken) {</span>
    case START_ARRAY:
    case START_OBJECT:
<span class="nc" id="L150">      parser.skipChildren();</span>
<span class="nc" id="L151">      break;</span>
    case VALUE_FALSE:
    case VALUE_NULL:
    case VALUE_NUMBER_FLOAT:
    case VALUE_NUMBER_INT:
    case VALUE_STRING:
    case VALUE_TRUE:
      // do nothing
<span class="nc" id="L159">      break;</span>
    default:
      // error
<span class="nc" id="L162">      String msg = String.format(&quot;Unhandled JsonToken %s%s.&quot;,</span>
<span class="nc" id="L163">          toString(parser),</span>
<span class="nc" id="L164">          generateLocationMessage(parser));</span>
<span class="nc" id="L165">      LOGGER.error(msg);</span>
<span class="nc" id="L166">      throw new UnsupportedOperationException(msg);</span>
    }

    // advance past the value
<span class="nc" id="L170">    return parser.nextToken();</span>
  }
  //
  // @SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;) // acceptable
  // private static boolean checkEndOfValue(@NonNull JsonParser parser, @NonNull
  // JsonToken startToken) {
  // JsonToken currentToken = parser.getCurrentToken();
  //
  // boolean retval;
  // switch (startToken) { // NOPMD - intentional fall through
  // case START_OBJECT:
  // retval = JsonToken.END_OBJECT.equals(currentToken);
  // break;
  // case START_ARRAY:
  // retval = JsonToken.END_ARRAY.equals(currentToken);
  // break;
  // case VALUE_EMBEDDED_OBJECT:
  // case VALUE_FALSE:
  // case VALUE_NULL:
  // case VALUE_NUMBER_FLOAT:
  // case VALUE_NUMBER_INT:
  // case VALUE_STRING:
  // case VALUE_TRUE:
  // retval = true;
  // break;
  // default:
  // retval = false;
  // }
  // return retval;
  // }

  /**
   * Ensure that the current token is one of the provided tokens.
   * &lt;p&gt;
   * Note: This uses a Java assertion to support debugging in a whay that doesn't
   * impact parser performance during production operation.
   *
   * @param parser
   *          the JSON parser
   * @param expectedTokens
   *          the tokens for which one is expected to match against the current
   *          token
   */
  public static void assertCurrent(
      @NonNull JsonParser parser,
      @NonNull JsonToken... expectedTokens) {
<span class="nc" id="L216">    JsonToken current = parser.currentToken();</span>
<span class="nc" id="L217">    assert Arrays.stream(expectedTokens)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        .anyMatch(expected -&gt; expected.equals(current)) : generateExpectedMessage(</span>
            parser,
            expectedTokens,
<span class="nc" id="L221">            parser.currentToken());</span>
<span class="nc" id="L222">  }</span>

  // public static void assertCurrentIsFieldValue(@NonNull JsonParser parser) {
  // JsonToken token = parser.currentToken();
  // assert token.isStructStart() || token.isScalarValue() : String.format(
  // &quot;Expected a START_OBJECT, START_ARRAY, or VALUE_xxx token, but found
  // JsonToken '%s'%s.&quot;,
  // token,
  // generateLocationMessage(parser));
  // }

  /**
   * Ensure that the current token is the one expected and then advance the token
   * stream.
   *
   * @param parser
   *          the JSON parser
   * @param expectedToken
   *          the expected token
   * @return the next token
   * @throws IOException
   *           if an error occurred while reading the token stream
   */
  @Nullable
  public static JsonToken assertAndAdvance(
      @NonNull JsonParser parser,
      @NonNull JsonToken expectedToken)
      throws IOException {
<span class="nc" id="L250">    JsonToken token = parser.currentToken();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    assert expectedToken.equals(token) : generateExpectedMessage(</span>
        parser,
        expectedToken,
        token);
<span class="nc" id="L255">    return parser.nextToken();</span>
  }

  /**
   * Advance the token stream, then ensure that the current token is the one
   * expected.
   *
   * @param parser
   *          the JSON parser
   * @param expectedToken
   *          the expected token
   * @return the next token
   * @throws IOException
   *           if an error occurred while reading the token stream
   */
  @Nullable
  public static JsonToken advanceAndAssert(
      @NonNull JsonParser parser,
      @NonNull JsonToken expectedToken)
      throws IOException {
<span class="nc" id="L275">    JsonToken token = parser.nextToken();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">    assert expectedToken.equals(token) : generateExpectedMessage(</span>
        parser,
        expectedToken,
        token);
<span class="nc" id="L280">    return token;</span>
  }

  /**
   * Generate a message intended for error reporting based on a presumed token.
   *
   * @param parser
   *          the JSON parser
   * @param expectedToken
   *          the expected token
   * @param actualToken
   *          the actual token found
   * @return the message string
   */
  @NonNull
  private static String generateExpectedMessage(
      @NonNull JsonParser parser,
      @NonNull JsonToken expectedToken,
      JsonToken actualToken) {
<span class="nc" id="L299">    return ObjectUtils.notNull(</span>
<span class="nc" id="L300">        String.format(&quot;Expected JsonToken '%s', but found JsonToken '%s'%s.&quot;,</span>
            expectedToken,
            actualToken,
<span class="nc" id="L303">            generateLocationMessage(parser)));</span>
  }

  /**
   * Generate a message intended for error reporting based on a presumed set of
   * tokens.
   *
   * @param parser
   *          the JSON parser
   * @param expectedTokens
   *          the set of expected tokens, one of which was expected to match the
   *          actual token
   * @param actualToken
   *          the actual token found
   * @return the message string
   */
  @NonNull
  private static String generateExpectedMessage(
      @NonNull JsonParser parser,
      @NonNull JsonToken[] expectedTokens,
      JsonToken actualToken) {
<span class="nc" id="L324">    List&lt;JsonToken&gt; expectedTokensList = ObjectUtils.notNull(Arrays.asList(expectedTokens));</span>
<span class="nc" id="L325">    return generateExpectedMessage(parser, expectedTokensList, actualToken);</span>
  }

  /**
   * Generate a message intended for error reporting based on a presumed set of
   * tokens.
   *
   * @param parser
   *          the JSON parser
   * @param expectedTokens
   *          the set of expected tokens, one of which was expected to match the
   *          actual token
   * @param actualToken
   *          the actual token found
   * @return the message string
   */
  @NonNull
  private static String generateExpectedMessage(
      @NonNull JsonParser parser,
      @NonNull Collection&lt;JsonToken&gt; expectedTokens,
      JsonToken actualToken) {
<span class="nc" id="L346">    return ObjectUtils.notNull(</span>
<span class="nc" id="L347">        String.format(&quot;Expected JsonToken(s) '%s', but found JsonToken '%s'%s.&quot;,</span>
<span class="nc" id="L348">            expectedTokens.stream().map(Enum::name).collect(CustomCollectors.joiningWithOxfordComma(&quot;or&quot;)),</span>
            actualToken,
<span class="nc" id="L350">            generateLocationMessage(parser)));</span>
  }

  /**
   * Generate a location string for the current location in the JSON token stream.
   *
   * @param parser
   *          the JSON parser
   * @return the location string
   */
  @NonNull
  public static CharSequence generateLocationMessage(@NonNull JsonParser parser) {
<span class="nc" id="L362">    JsonLocation location = parser.getCurrentLocation();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    return location == null ? &quot;&quot; : generateLocationMessage(location);</span>
  }

  /**
   * Generate a location string for the current location in the JSON token stream.
   *
   * @param location
   *          a JSON token stream location
   * @return the location string
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static CharSequence generateLocationMessage(@NonNull JsonLocation location) {
<span class="nc" id="L376">    return new StringBuilder()</span>
<span class="nc" id="L377">        .append(&quot; at location '&quot;)</span>
<span class="nc" id="L378">        .append(location.getLineNr())</span>
<span class="nc" id="L379">        .append(':')</span>
<span class="nc" id="L380">        .append(location.getColumnNr())</span>
<span class="nc" id="L381">        .append('\'');</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>