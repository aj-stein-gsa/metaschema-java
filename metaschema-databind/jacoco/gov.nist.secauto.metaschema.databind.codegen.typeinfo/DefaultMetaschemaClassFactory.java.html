<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMetaschemaClassFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.codegen.typeinfo</a> &gt; <span class="el_source">DefaultMetaschemaClassFactory.java</span></div><h1>DefaultMetaschemaClassFactory.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.codegen.typeinfo;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;

import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IDefinition;
import gov.nist.secauto.metaschema.core.model.IFieldDefinition;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.IModelDefinition;
import gov.nist.secauto.metaschema.core.model.IModule;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.IBindingContext;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedClass;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedDefinitionClass;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedModuleClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.AnnotationGenerator;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedDefinitionClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedModuleClass;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IAssemblyDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IFieldDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IModelDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.model.AbstractBoundModule;
import gov.nist.secauto.metaschema.databind.model.IBoundModule;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaField;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaModule;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaPackage;
import gov.nist.secauto.metaschema.databind.model.annotations.NsBinding;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlNs;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlNsForm;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlSchema;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.lang.model.element.Modifier;

import edu.umd.cs.findbugs.annotations.NonNull;

<span class="fc" id="L72">@SuppressWarnings({</span>
    &quot;PMD.CouplingBetweenObjects&quot;, // ok
    &quot;PMD.GodClass&quot;, // ok
    &quot;PMD.CyclomaticComplexity&quot; // ok
})
public class DefaultMetaschemaClassFactory implements IMetaschemaClassFactory {
  @NonNull
  private final ITypeResolver typeResolver;

  /**
   * Get a new instance of the this class generation factory that uses the
   * provided {@code typeResolver}.
   *
   * @param typeResolver
   *          the resolver used to generate type information for Metasschema
   *          constructs
   * @return the new class factory
   */
  @NonNull
  public static DefaultMetaschemaClassFactory newInstance(@NonNull ITypeResolver typeResolver) {
<span class="fc" id="L92">    return new DefaultMetaschemaClassFactory(typeResolver);</span>
  }

  /**
   * Construct a new instance of the this class ganeration factory that uses the
   * provided {@code typeResolver}.
   *
   * @param typeResolver
   *          the resolver used to generate type information for Metasschema
   *          constructs
   */
<span class="fc" id="L103">  protected DefaultMetaschemaClassFactory(@NonNull ITypeResolver typeResolver) {</span>
<span class="fc" id="L104">    this.typeResolver = typeResolver;</span>
<span class="fc" id="L105">  }</span>

  @Override
  @NonNull
  public ITypeResolver getTypeResolver() {
<span class="fc" id="L110">    return typeResolver;</span>
  }

  @Override
  public IGeneratedModuleClass generateClass(
      IModule module,
      Path targetDirectory) throws IOException {

    // Generate the Module module class
<span class="fc" id="L119">    ClassName className = getTypeResolver().getClassName(module);</span>

<span class="fc" id="L121">    TypeSpec.Builder classSpec = newClassBuilder(module, className);</span>

<span class="fc" id="L123">    JavaFile javaFile = JavaFile.builder(className.packageName(), classSpec.build()).build();</span>
<span class="fc" id="L124">    Path classFile = ObjectUtils.notNull(javaFile.writeToPath(targetDirectory));</span>

    // now generate all related definition classes
<span class="fc" id="L127">    Stream&lt;? extends IModelDefinition&gt; globalDefinitions = Stream.concat(</span>
<span class="fc" id="L128">        module.getAssemblyDefinitions().stream(),</span>
<span class="fc" id="L129">        module.getFieldDefinitions().stream());</span>

<span class="fc" id="L131">    Set&lt;String&gt; classNames = new LinkedHashSet&lt;&gt;();</span>

    @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;) // map is unmodifiable
<span class="fc" id="L134">    Map&lt;IModelDefinition, IGeneratedDefinitionClass&gt; definitionProductions</span>
<span class="fc" id="L135">        = ObjectUtils.notNull(globalDefinitions</span>
            // Get type information for assembly and field definitions.
            // Avoid field definitions without flags that don't require a generated class
<span class="fc" id="L138">            .flatMap(definition -&gt; {</span>
<span class="fc" id="L139">              IModelDefinitionTypeInfo typeInfo = null;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">              if (definition instanceof IAssemblyDefinition) {</span>
<span class="fc" id="L141">                typeInfo = IAssemblyDefinitionTypeInfo.newTypeInfo((IAssemblyDefinition) definition, typeResolver);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">              } else if (definition instanceof IFieldDefinition</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                  &amp;&amp; !((IFieldDefinition) definition).getFlagInstances().isEmpty()) {</span>
<span class="fc" id="L144">                typeInfo = IFieldDefinitionTypeInfo.newTypeInfo((IFieldDefinition) definition, typeResolver);</span>
              } // otherwise field is just a simple data value, then no class is needed
<span class="fc bfc" id="L146" title="All 2 branches covered.">              return typeInfo == null ? null : Stream.of(typeInfo);</span>
            })
            // generate the class for each type information
<span class="fc" id="L149">            .map(typeInfo -&gt; {</span>
<span class="fc" id="L150">              IModelDefinition definition = typeInfo.getDefinition();</span>
              IGeneratedDefinitionClass generatedClass;
              try {
<span class="fc" id="L153">                generatedClass = generateClass(typeInfo, targetDirectory);</span>
<span class="nc" id="L154">              } catch (RuntimeException ex) { // NOPMD - intended</span>
<span class="nc" id="L155">                throw new IllegalStateException(</span>
<span class="nc" id="L156">                    String.format(&quot;Unable to generate class for definition '%s' in Module '%s'&quot;,</span>
<span class="nc" id="L157">                        definition.getName(),</span>
<span class="nc" id="L158">                        module.getLocation()),</span>
                    ex);
<span class="nc" id="L160">              } catch (IOException ex) {</span>
<span class="nc" id="L161">                throw new IllegalStateException(ex);</span>
<span class="fc" id="L162">              }</span>
<span class="fc" id="L163">              String defClassName = generatedClass.getClassName().canonicalName();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">              if (classNames.contains(defClassName)) {</span>
<span class="nc" id="L165">                throw new IllegalStateException(String.format(</span>
                    &quot;Found duplicate class '%s' in metaschema '%s'.&quot;
                        + &quot; All class names must be unique within the same namespace.&quot;,
<span class="nc" id="L168">                    defClassName, module.getLocation()));</span>
              }
<span class="fc" id="L170">              classNames.add(defClassName);</span>
<span class="fc" id="L171">              return generatedClass;</span>
            })
            // collect the generated class information
<span class="fc" id="L174">            .collect(Collectors.toUnmodifiableMap(</span>
                IGeneratedDefinitionClass::getDefinition,
<span class="fc" id="L176">                Function.identity())));</span>
<span class="fc" id="L177">    String packageName = typeResolver.getPackageName(module);</span>
<span class="fc" id="L178">    return new DefaultGeneratedModuleClass(module, className, classFile, definitionProductions, packageName);</span>
  }

  @Override
  public IGeneratedDefinitionClass generateClass(
      IModelDefinitionTypeInfo typeInfo,
      Path targetDirectory)
      throws IOException {
<span class="fc" id="L186">    ClassName className = typeInfo.getClassName();</span>

<span class="fc" id="L188">    TypeSpec.Builder classSpec = newClassBuilder(typeInfo, false);</span>

<span class="fc" id="L190">    JavaFile javaFile = JavaFile.builder(className.packageName(), classSpec.build()).build();</span>
<span class="fc" id="L191">    Path classFile = ObjectUtils.notNull(javaFile.writeToPath(targetDirectory));</span>

<span class="fc" id="L193">    return new DefaultGeneratedDefinitionClass(classFile, className, typeInfo.getDefinition());</span>
  }

  @Override
  public IGeneratedClass generatePackageInfoClass(
      String javaPackage,
      URI xmlNamespace,
      Collection&lt;IGeneratedModuleClass&gt; moduleProductions,
      Path targetDirectory) throws IOException {

<span class="fc" id="L203">    String packagePath = javaPackage.replace(&quot;.&quot;, &quot;/&quot;);</span>
<span class="fc" id="L204">    Path packageInfo = ObjectUtils.notNull(targetDirectory.resolve(packagePath + &quot;/package-info.java&quot;));</span>

<span class="fc" id="L206">    try (PrintWriter writer = new PrintWriter(</span>
<span class="fc" id="L207">        Files.newBufferedWriter(packageInfo, StandardOpenOption.CREATE, StandardOpenOption.WRITE,</span>
            StandardOpenOption.TRUNCATE_EXISTING))) {
<span class="fc" id="L209">      writer.format(&quot;@%1$s(moduleClass = {%n&quot;, MetaschemaPackage.class.getName());</span>

<span class="fc" id="L211">      boolean first = true;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      for (IGeneratedModuleClass moduleProduction : moduleProductions) {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (first) {</span>
<span class="fc" id="L214">          first = false;</span>
        } else {
<span class="fc" id="L216">          writer.format(&quot;,%n&quot;);</span>
        }
<span class="fc" id="L218">        writer.format(&quot;  %1$s.class&quot;, moduleProduction.getClassName().canonicalName());</span>
<span class="fc" id="L219">      }</span>

<span class="fc" id="L221">      writer.format(&quot;})%n&quot;);</span>

<span class="fc" id="L223">      writer.format(</span>
          &quot;@%1$s(namespace = \&quot;%2$s\&quot;, xmlns = {@%3$s(prefix = \&quot;\&quot;, namespace = \&quot;%2$s\&quot;)},&quot;
              + &quot; xmlElementFormDefault = %4$s.QUALIFIED)%n&quot;,
<span class="fc" id="L226">          XmlSchema.class.getName(), xmlNamespace.toString(), XmlNs.class.getName(), XmlNsForm.class.getName());</span>
<span class="fc" id="L227">      writer.format(&quot;package %s;%n&quot;, javaPackage);</span>
    }

<span class="fc" id="L230">    return new DefaultGeneratedClass(packageInfo, ObjectUtils.notNull(ClassName.get(javaPackage, &quot;package-info&quot;)));</span>
  }

  /**
   * Creates and configures a builder, for a Module module, that can be used to
   * generate a Java class.
   *
   * @param module
   *          a parsed Module module
   * @param className
   *          the name of the class to create for the Module module
   * @return the class builder
   */
  @NonNull
  protected TypeSpec.Builder newClassBuilder(
      @NonNull IModule module,
      @NonNull ClassName className) { // NOPMD - long, but readable

    // create the class
<span class="fc" id="L249">    TypeSpec.Builder builder = TypeSpec.classBuilder(className)</span>
<span class="fc" id="L250">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L251">        .addModifiers(Modifier.FINAL);</span>

<span class="fc" id="L253">    builder.superclass(AbstractBoundModule.class);</span>

<span class="fc" id="L255">    AnnotationSpec.Builder moduleAnnotation = AnnotationSpec.builder(MetaschemaModule.class);</span>

<span class="fc" id="L257">    ITypeResolver typeResolver = getTypeResolver();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">    for (IFieldDefinition definition : module.getFieldDefinitions()) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      if (definition.hasChildren()) {</span>
<span class="fc" id="L260">        moduleAnnotation.addMember(&quot;fields&quot;, &quot;$T.class&quot;, typeResolver.getClassName(definition));</span>
      }
<span class="fc" id="L262">    }</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">    for (IAssemblyDefinition definition : module.getAssemblyDefinitions()) {</span>
<span class="fc" id="L265">      moduleAnnotation.addMember(</span>
          &quot;assemblies&quot;,
          &quot;$T.class&quot;,
<span class="fc" id="L268">          typeResolver.getClassName(ObjectUtils.notNull(definition)));</span>
<span class="fc" id="L269">    }</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">    for (IModule moduleImport : module.getImportedModules()) {</span>
<span class="fc" id="L272">      moduleAnnotation.addMember(</span>
          &quot;imports&quot;,
          &quot;$T.class&quot;,
<span class="fc" id="L275">          typeResolver.getClassName(ObjectUtils.notNull(moduleImport)));</span>
<span class="fc" id="L276">    }</span>

<span class="fc" id="L278">    Map&lt;String, String&gt; bindings = module.getNamespaceBindings();</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (!bindings.isEmpty()) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      for (Map.Entry&lt;String, String&gt; binding : bindings.entrySet()) {</span>
<span class="nc" id="L281">        moduleAnnotation.addMember(</span>
            &quot;nsBindings&quot;,
            &quot;$L&quot;,
<span class="nc" id="L284">            AnnotationSpec.builder(NsBinding.class)</span>
<span class="nc" id="L285">                .addMember(&quot;prefix&quot;, &quot;$S&quot;, binding.getKey())</span>
<span class="nc" id="L286">                .addMember(&quot;uri&quot;, &quot;$S&quot;, binding.getValue()));</span>
<span class="nc" id="L287">      }</span>
    }

    {
<span class="fc" id="L291">      MarkupMultiline remarks = module.getRemarks();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L293">        moduleAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
    }

<span class="fc" id="L297">    builder.addAnnotation(moduleAnnotation.build());</span>

<span class="fc" id="L299">    builder.addField(</span>
<span class="fc" id="L300">        FieldSpec.builder(MarkupLine.class, &quot;NAME&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L301">            .initializer(&quot;$T.fromMarkdown($S)&quot;, MarkupLine.class, module.getName().toMarkdown())</span>
<span class="fc" id="L302">            .build());</span>

<span class="fc" id="L304">    builder.addField(</span>
<span class="fc" id="L305">        FieldSpec.builder(String.class, &quot;SHORT_NAME&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L306">            .initializer(&quot;$S&quot;, module.getShortName())</span>
<span class="fc" id="L307">            .build());</span>

<span class="fc" id="L309">    builder.addField(</span>
<span class="fc" id="L310">        FieldSpec.builder(String.class, &quot;VERSION&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L311">            .initializer(&quot;$S&quot;, module.getVersion())</span>
<span class="fc" id="L312">            .build());</span>

<span class="fc" id="L314">    builder.addField(</span>
<span class="fc" id="L315">        FieldSpec.builder(URI.class, &quot;XML_NAMESPACE&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L316">            .initializer(&quot;$T.create($S)&quot;, URI.class, module.getXmlNamespace())</span>
<span class="fc" id="L317">            .build());</span>

<span class="fc" id="L319">    builder.addField(</span>
<span class="fc" id="L320">        FieldSpec.builder(URI.class, &quot;JSON_BASE_URI&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L321">            .initializer(&quot;$T.create($S)&quot;, URI.class, module.getJsonBaseUri())</span>
<span class="fc" id="L322">            .build());</span>

<span class="fc" id="L324">    MarkupMultiline remarks = module.getRemarks();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (remarks != null) {</span>
<span class="fc" id="L326">      builder.addField(</span>
<span class="fc" id="L327">          FieldSpec.builder(MarkupMultiline.class, &quot;REMARKS&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L328">              .initializer(&quot;$T.fromMarkdown($S)&quot;, MarkupMultiline.class, remarks.toMarkdown())</span>
<span class="fc" id="L329">              .build());</span>
    }

<span class="fc" id="L332">    builder.addMethod(</span>
<span class="fc" id="L333">        MethodSpec.constructorBuilder()</span>
<span class="fc" id="L334">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L335">            .addParameter(</span>
<span class="fc" id="L336">                ParameterizedTypeName.get(ClassName.get(List.class),</span>
<span class="fc" id="L337">                    WildcardTypeName.subtypeOf(IBoundModule.class).box()),</span>
                &quot;importedModules&quot;)
<span class="fc" id="L339">            .addParameter(IBindingContext.class, &quot;bindingContext&quot;)</span>
<span class="fc" id="L340">            .addStatement(&quot;super($N, $N)&quot;, &quot;importedModules&quot;, &quot;bindingContext&quot;)</span>
<span class="fc" id="L341">            .build());</span>
<span class="fc" id="L342">    builder.addMethod(</span>
<span class="fc" id="L343">        MethodSpec.methodBuilder(&quot;getName&quot;)</span>
<span class="fc" id="L344">            .addAnnotation(Override.class)</span>
<span class="fc" id="L345">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L346">            .returns(MarkupLine.class)</span>
<span class="fc" id="L347">            .addStatement(&quot;return NAME&quot;)</span>
<span class="fc" id="L348">            .build());</span>

<span class="fc" id="L350">    builder.addMethod(</span>
<span class="fc" id="L351">        MethodSpec.methodBuilder(&quot;getShortName&quot;)</span>
<span class="fc" id="L352">            .addAnnotation(Override.class)</span>
<span class="fc" id="L353">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L354">            .returns(String.class)</span>
<span class="fc" id="L355">            .addStatement(&quot;return SHORT_NAME&quot;)</span>
<span class="fc" id="L356">            .build());</span>

<span class="fc" id="L358">    builder.addMethod(</span>
<span class="fc" id="L359">        MethodSpec.methodBuilder(&quot;getVersion&quot;)</span>
<span class="fc" id="L360">            .addAnnotation(Override.class)</span>
<span class="fc" id="L361">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L362">            .returns(String.class)</span>
<span class="fc" id="L363">            .addStatement(&quot;return VERSION&quot;)</span>
<span class="fc" id="L364">            .build());</span>

<span class="fc" id="L366">    builder.addMethod(</span>
<span class="fc" id="L367">        MethodSpec.methodBuilder(&quot;getXmlNamespace&quot;)</span>
<span class="fc" id="L368">            .addAnnotation(Override.class)</span>
<span class="fc" id="L369">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L370">            .returns(URI.class)</span>
<span class="fc" id="L371">            .addStatement(&quot;return XML_NAMESPACE&quot;)</span>
<span class="fc" id="L372">            .build());</span>

<span class="fc" id="L374">    builder.addMethod(</span>
<span class="fc" id="L375">        MethodSpec.methodBuilder(&quot;getJsonBaseUri&quot;)</span>
<span class="fc" id="L376">            .addAnnotation(Override.class)</span>
<span class="fc" id="L377">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L378">            .returns(URI.class)</span>
<span class="fc" id="L379">            .addStatement(&quot;return JSON_BASE_URI&quot;)</span>
<span class="fc" id="L380">            .build());</span>

<span class="fc" id="L382">    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(&quot;getRemarks&quot;)</span>
<span class="fc" id="L383">        .addAnnotation(Override.class)</span>
<span class="fc" id="L384">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L385">        .returns(MarkupMultiline.class);</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (remarks == null) {</span>
<span class="fc" id="L388">      methodBuilder.addStatement(&quot;return null&quot;);</span>
    } else {
<span class="fc" id="L390">      methodBuilder.addStatement(&quot;return REMARKS&quot;);</span>
    }

<span class="fc" id="L393">    builder.addMethod(methodBuilder.build());</span>

<span class="fc" id="L395">    return builder;</span>
  }

  /**
   * Creates and configures a builder, for a Module model definition, that can be
   * used to generate a Java class.
   *
   * @param typeInfo
   *          the type information for the class to generate
   * @param isChild
   *          {@code true} if the class to be generated is a child class, or
   *          {@code false} otherwise
   * @return the class builder
   * @throws IOException
   *           if an error occurred while building the Java class
   */
  @NonNull
  protected TypeSpec.Builder newClassBuilder(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      boolean isChild) throws IOException {
    // create the class
<span class="fc" id="L416">    TypeSpec.Builder builder = TypeSpec.classBuilder(typeInfo.getClassName())</span>
<span class="fc" id="L417">        .addModifiers(Modifier.PUBLIC);</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">    assert builder != null;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">    if (isChild) {</span>
<span class="fc" id="L420">      builder.addModifiers(Modifier.STATIC);</span>
    }
    // builder.addModifiers(Modifier.FINAL);

<span class="fc" id="L424">    builder.addSuperinterface(ClassName.get(IBoundObject.class));</span>

    // add field for Metaschema info
<span class="fc" id="L427">    builder.addField(FieldSpec.builder(IMetaschemaData.class, &quot;__metaschemaData&quot;, Modifier.PRIVATE, Modifier.FINAL)</span>
<span class="fc" id="L428">        .build());</span>

<span class="fc" id="L430">    builder.addMethod(MethodSpec.constructorBuilder()</span>
<span class="fc" id="L431">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L432">        .addStatement(&quot;this(null)&quot;)</span>
<span class="fc" id="L433">        .build());</span>

<span class="fc" id="L435">    builder.addMethod(MethodSpec.constructorBuilder()</span>
<span class="fc" id="L436">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L437">        .addParameter(IMetaschemaData.class, &quot;data&quot;)</span>
<span class="fc" id="L438">        .addStatement(&quot;this.$N = $N&quot;, &quot;__metaschemaData&quot;, &quot;data&quot;)</span>
<span class="fc" id="L439">        .build());</span>

    // generate a toString method that will help with debugging
<span class="fc" id="L442">    MethodSpec.Builder getMetaschemaData = MethodSpec.methodBuilder(&quot;getMetaschemaData&quot;)</span>
<span class="fc" id="L443">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L444">        .returns(IMetaschemaData.class)</span>
<span class="fc" id="L445">        .addAnnotation(Override.class)</span>
<span class="fc" id="L446">        .addStatement(&quot;return __metaschemaData&quot;);</span>
<span class="fc" id="L447">    builder.addMethod(getMetaschemaData.build());</span>

<span class="fc" id="L449">    ClassName baseClassName = typeInfo.getBaseClassName();</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">    if (baseClassName != null) {</span>
<span class="nc" id="L451">      builder.superclass(baseClassName);</span>
    }

<span class="pc bpc" id="L454" title="1 of 2 branches missed.">    for (ClassName superinterface : typeInfo.getSuperinterfaces()) {</span>
<span class="nc" id="L455">      builder.addSuperinterface(superinterface);</span>
<span class="nc" id="L456">    }</span>

    Set&lt;IModelDefinition&gt; additionalChildClasses;
<span class="fc bfc" id="L459" title="All 2 branches covered.">    if (typeInfo instanceof IAssemblyDefinitionTypeInfo) {</span>
<span class="fc" id="L460">      additionalChildClasses = buildClass((IAssemblyDefinitionTypeInfo) typeInfo, builder);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">    } else if (typeInfo instanceof IFieldDefinitionTypeInfo) {</span>
<span class="fc" id="L462">      additionalChildClasses = buildClass((IFieldDefinitionTypeInfo) typeInfo, builder);</span>
    } else {
<span class="nc" id="L464">      throw new UnsupportedOperationException(</span>
<span class="nc" id="L465">          String.format(&quot;Unsupported type: %s&quot;, typeInfo.getClass().getName()));</span>
    }

<span class="fc" id="L468">    ITypeResolver typeResolver = getTypeResolver();</span>

<span class="fc bfc" id="L470" title="All 2 branches covered.">    for (IModelDefinition definition : additionalChildClasses) {</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">      assert definition != null;</span>
<span class="fc" id="L472">      IModelDefinitionTypeInfo childTypeInfo = typeResolver.getTypeInfo(definition);</span>
<span class="fc" id="L473">      TypeSpec childClass = newClassBuilder(childTypeInfo, true).build();</span>
<span class="fc" id="L474">      builder.addType(childClass);</span>
<span class="fc" id="L475">    }</span>
<span class="fc" id="L476">    return ObjectUtils.notNull(builder);</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IAssemblyDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L493">    AnnotationSpec.Builder metaschemaAssembly = ObjectUtils.notNull(AnnotationSpec.builder(MetaschemaAssembly.class));</span>

<span class="fc" id="L495">    buildCommonProperties(typeInfo, metaschemaAssembly);</span>

<span class="fc" id="L497">    IAssemblyDefinition definition = typeInfo.getDefinition();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (definition.isRoot()) {</span>
<span class="fc" id="L499">      metaschemaAssembly.addMember(&quot;rootName&quot;, &quot;$S&quot;, definition.getRootName());</span>
    }

<span class="fc" id="L502">    MarkupMultiline remarks = definition.getRemarks();</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (remarks != null) {</span>
<span class="fc" id="L504">      metaschemaAssembly.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
    }

<span class="fc" id="L507">    AnnotationGenerator.buildValueConstraints(metaschemaAssembly, definition);</span>
<span class="fc" id="L508">    AnnotationGenerator.buildAssemblyConstraints(metaschemaAssembly, definition);</span>

<span class="fc" id="L510">    builder.addAnnotation(metaschemaAssembly.build());</span>

<span class="fc" id="L512">    return new LinkedHashSet&lt;&gt;(buildClass((IModelDefinitionTypeInfo) typeInfo, builder));</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IFieldDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L529">    AnnotationSpec.Builder metaschemaField = ObjectUtils.notNull(AnnotationSpec.builder(MetaschemaField.class));</span>

<span class="fc" id="L531">    buildCommonProperties(typeInfo, metaschemaField);</span>

<span class="fc" id="L533">    IFieldDefinition definition = typeInfo.getDefinition();</span>
<span class="fc" id="L534">    AnnotationGenerator.buildValueConstraints(metaschemaField, definition);</span>

<span class="fc" id="L536">    builder.addAnnotation(metaschemaField.build());</span>

<span class="fc" id="L538">    return new LinkedHashSet&lt;&gt;(buildClass((IModelDefinitionTypeInfo) typeInfo, builder));</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  @NonNull
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L556">    MarkupLine description = typeInfo.getDefinition().getDescription();</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">    if (description != null) {</span>
<span class="fc" id="L558">      builder.addJavadoc(description.toHtml());</span>
    }

<span class="fc" id="L561">    Set&lt;IModelDefinition&gt; additionalChildClasses = new LinkedHashSet&lt;&gt;();</span>

    // // generate a no-arg constructor
    // builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build());

    // // generate a copy constructor
    // MethodSpec.Builder copyBuilder =
    // MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);
    // copyBuilder.addParameter(className, &quot;that&quot;, Modifier.FINAL);
    // for (IPropertyGenerator property : getPropertyGenerators()) {
    // additionalChildClasses.addAll(property.buildCopyStatements(copyBuilder,
    // getTypeResolver()));
    // }
    // builder.addMethod(copyBuilder.build());

    // generate all the properties and access methods
<span class="fc bfc" id="L577" title="All 2 branches covered.">    for (IPropertyTypeInfo property : typeInfo.getPropertyTypeInfos()) {</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">      assert property != null;</span>
<span class="fc" id="L579">      additionalChildClasses.addAll(property.build(builder));</span>
<span class="fc" id="L580">    }</span>

    // generate a toString method that will help with debugging
<span class="fc" id="L583">    MethodSpec.Builder toString = MethodSpec.methodBuilder(&quot;toString&quot;).addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L584">        .returns(String.class).addAnnotation(Override.class);</span>
<span class="fc" id="L585">    toString.addStatement(&quot;return new $T(this, $T.MULTI_LINE_STYLE).toString()&quot;, ReflectionToStringBuilder.class,</span>
        ToStringStyle.class);
<span class="fc" id="L587">    builder.addMethod(toString.build());</span>
<span class="fc" id="L588">    return CollectionUtil.unmodifiableSet(additionalChildClasses);</span>
  }

  /**
   * Build the core property annotations that are common to all Module classes.
   *
   * @param typeInfo
   *          the type information for the Java property to build
   * @param builder
   *          the class builder
   */
  protected void buildCommonProperties(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      @NonNull AnnotationSpec.Builder builder) {
<span class="fc" id="L602">    IDefinition definition = typeInfo.getDefinition();</span>

<span class="fc" id="L604">    String formalName = definition.getEffectiveFormalName();</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">    if (formalName != null) {</span>
<span class="fc" id="L606">      builder.addMember(&quot;formalName&quot;, &quot;$S&quot;, formalName);</span>
    }

<span class="fc" id="L609">    MarkupLine description = definition.getEffectiveDescription();</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">    if (description != null) {</span>
<span class="fc" id="L611">      builder.addMember(&quot;description&quot;, &quot;$S&quot;, description.toMarkdown());</span>
    }

<span class="fc" id="L614">    builder.addMember(&quot;name&quot;, &quot;$S&quot;, definition.getName());</span>
<span class="fc" id="L615">    IModule module = definition.getContainingModule();</span>
<span class="fc" id="L616">    builder.addMember(&quot;moduleClass&quot;, &quot;$T.class&quot;, getTypeResolver().getClassName(module));</span>
<span class="fc" id="L617">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>