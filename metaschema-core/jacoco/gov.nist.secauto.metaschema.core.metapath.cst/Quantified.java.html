<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Quantified.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.cst</a> &gt; <span class="el_source">Quantified.java</span></div><h1>Quantified.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.cst;

import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnBoolean;
import gov.nist.secauto.metaschema.core.metapath.item.IItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IBooleanItem;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;

<span class="fc" id="L30">public class Quantified</span>
    extends AbstractExpression {
<span class="fc" id="L32">  public enum Quantifier {</span>
<span class="fc" id="L33">    SOME,</span>
<span class="fc" id="L34">    EVERY;</span>
  }

  @NonNull
  private final Quantifier quantifier;
  @NonNull
  private final Map&lt;QName, IExpression&gt; inClauses;
  @NonNull
  private final IExpression satisfies;

  /**
   * Construct a new quantified expression.
   *
   * @param quantifier
   *          the quantifier operation
   * @param inClauses
   *          the set of expressions that define the variables to use for
   *          determining the Cartesian product for evaluation
   * @param satisfies
   *          the expression used for evaluation using the Cartesian product of
   *          the variables
   */
  public Quantified(
      @NonNull Quantifier quantifier,
      @NonNull Map&lt;QName, IExpression&gt; inClauses,
<span class="fc" id="L59">      @NonNull IExpression satisfies) {</span>
<span class="fc" id="L60">    this.quantifier = quantifier;</span>
<span class="fc" id="L61">    this.inClauses = inClauses;</span>
<span class="fc" id="L62">    this.satisfies = satisfies;</span>
<span class="fc" id="L63">  }</span>

  /**
   * Get the quantifier operation.
   *
   * @return the quantifier operations
   */
  @NonNull
  public Quantifier getQuantifier() {
<span class="nc" id="L72">    return quantifier;</span>
  }

  /**
   * Get the set of expressions that define the variables to use for determining
   * the Cartesian product for evaluation.
   *
   * @return the variable names mapped to the associated Metapath expression
   */
  @NonNull
  public Map&lt;QName, IExpression&gt; getInClauses() {
<span class="fc" id="L83">    return inClauses;</span>
  }

  /**
   * Get the expression used for evaluation using the Cartesian product of the
   * variables.
   *
   * @return the evaluation expression
   */
  @NonNull
  public IExpression getSatisfies() {
<span class="fc" id="L94">    return satisfies;</span>
  }

  @Override
  public List&lt;? extends IExpression&gt; getChildren() {
<span class="fc" id="L99">    return ObjectUtils.notNull(Stream.concat(inClauses.values().stream(), Stream.of(satisfies))</span>
<span class="fc" id="L100">        .collect(Collectors.toList()));</span>
  }

  @SuppressWarnings(&quot;PMD.SystemPrintln&quot;)
  @Override
  public ISequence&lt;? extends IItem&gt; accept(DynamicContext dynamicContext, ISequence&lt;?&gt; focus) {
<span class="fc" id="L106">    Map&lt;QName, ISequence&lt;? extends IItem&gt;&gt; clauses = getInClauses().entrySet().stream()</span>
<span class="fc" id="L107">        .map(entry -&gt; Map.entry(</span>
<span class="fc" id="L108">            entry.getKey(),</span>
<span class="fc" id="L109">            entry.getValue().accept(dynamicContext, focus)))</span>
<span class="pc" id="L110">        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new));</span>

<span class="fc" id="L112">    List&lt;QName&gt; clauseKeys = new ArrayList&lt;&gt;(clauses.keySet());</span>
<span class="fc" id="L113">    List&lt;? extends Collection&lt;? extends IItem&gt;&gt; clauseValues = new ArrayList&lt;&gt;(clauses.values());</span>

<span class="fc" id="L115">    boolean retval = true;</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">    for (List&lt;IItem&gt; product : new CartesianProduct&lt;&gt;(clauseValues)) {</span>
<span class="fc" id="L117">      DynamicContext subDynamicContext = dynamicContext.subContext();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">      for (int idx = 0; idx &lt; product.size(); idx++) {</span>
<span class="fc" id="L119">        QName var = clauseKeys.get(idx);</span>
<span class="fc" id="L120">        IItem item = product.get(idx);</span>

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        assert var != null;</span>

<span class="fc" id="L124">        subDynamicContext.bindVariableValue(var, ISequence.of(item));</span>
      }
<span class="fc" id="L126">      boolean result = FnBoolean.fnBooleanAsPrimitive(getSatisfies().accept(subDynamicContext, focus));</span>
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">      if (Quantifier.EVERY.equals(quantifier) &amp;&amp; !result) {</span>
        // fail on first false
<span class="fc" id="L129">        retval = false;</span>
<span class="fc" id="L130">        break;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">      } else if (Quantifier.SOME.equals(quantifier)) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (result) {</span>
          // pass on first true
<span class="fc" id="L134">          retval = true;</span>
<span class="fc" id="L135">          break;</span>
        }
        // store (false) result
<span class="fc" id="L138">        retval = false;</span>
      }
<span class="fc" id="L140">    }</span>

<span class="fc" id="L142">    return ISequence.of(IBooleanItem.valueOf(retval));</span>
  }

  @Override
  public &lt;RESULT, CONTEXT&gt; RESULT accept(IExpressionVisitor&lt;RESULT, CONTEXT&gt; visitor, CONTEXT context) {
<span class="fc" id="L147">    return visitor.visitQuantified(this, context);</span>
  }

  /**
   * Get the Cartesian product of the provided lists of value axis.
   *
   * @param &lt;T&gt;
   *          the Java type of value item
   * @param axes
   *          the values to compute the Cartesian product of
   * @return an iterator of lists contain the Cartesian product of the axis values
   */
  public static &lt;T extends IItem&gt; Iterable&lt;List&lt;T&gt;&gt; cartesianProduct(
      @NonNull List&lt;? extends Collection&lt;? extends T&gt;&gt; axes) {
<span class="nc" id="L161">    return new CartesianProduct&lt;&gt;(axes);</span>
  }

  // based on https://gist.github.com/jhorstmann/a7aba9947bc4926a75f6de8f69560c6e
  private static class CartesianProductIterator&lt;T extends IItem&gt; implements Iterator&lt;List&lt;T&gt;&gt; {
    private final Object[][] dimensions;
    private final int length;
    private final int[] indizes;
    private boolean reachedMax;

    @SuppressWarnings({
        &quot;PMD.UseVarargs&quot;,
        &quot;PMD.ArrayIsStoredDirectly&quot; // ok for internal use
    })
<span class="fc" id="L175">    CartesianProductIterator(final Object[][] dimensions) {</span>
<span class="fc" id="L176">      this.dimensions = dimensions;</span>
<span class="fc" id="L177">      this.length = dimensions.length;</span>
<span class="fc" id="L178">      this.indizes = new int[length];</span>
<span class="fc" id="L179">    }</span>

    private void increment(final int index) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">      if (index &gt;= length) {</span>
<span class="nc" id="L183">        reachedMax = true;</span>
      } else {
<span class="fc" id="L185">        indizes[index]++;</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (indizes[index] == dimensions[index].length) {</span>
<span class="nc" id="L187">          indizes[index] = 0;</span>
<span class="nc" id="L188">          increment(index + 1);</span>
        }
      }
<span class="fc" id="L191">    }</span>

    private void increment() {
<span class="fc" id="L194">      increment(0);</span>
<span class="fc" id="L195">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;T&gt; next() {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">      if (reachedMax) {</span>
<span class="nc" id="L201">        throw new NoSuchElementException();</span>
      }

<span class="fc" id="L204">      List&lt;T&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L206">        list.add((T) dimensions[i][indizes[i]]);</span>
      }

<span class="fc" id="L209">      increment();</span>

<span class="fc" id="L211">      return Collections.unmodifiableList(list);</span>
    }

    @Override
    public boolean hasNext() {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">      return !reachedMax;</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L221">      throw new UnsupportedOperationException(&quot;remove not supported&quot;);</span>
    }
  }

  // based on https://gist.github.com/jhorstmann/a7aba9947bc4926a75f6de8f69560c6e
  private static final class CartesianProduct&lt;T extends IItem&gt; implements Iterable&lt;List&lt;T&gt;&gt; {
    private final Object[][] dimensions;
    private final long size;

<span class="fc" id="L230">    private CartesianProduct(final List&lt;? extends Collection&lt;? extends T&gt;&gt; axes) {</span>
<span class="fc" id="L231">      Object[][] dimensions = new Object[axes.size()][];</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">      long size = dimensions.length == 0 ? 0 : 1;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">      for (int i = 0; i &lt; axes.size(); i++) {</span>
<span class="fc" id="L234">        dimensions[i] = axes.get(i).toArray();</span>
<span class="fc" id="L235">        size *= dimensions[i].length;</span>
      }
<span class="fc" id="L237">      this.dimensions = dimensions;</span>
<span class="fc" id="L238">      this.size = size;</span>
<span class="fc" id="L239">    }</span>

    @SuppressWarnings(&quot;PMD.OnlyOneReturn&quot;) // readability
    @Override
    public Iterator&lt;List&lt;T&gt;&gt; iterator() {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">      if (size == 0) {</span>
<span class="nc" id="L245">        return Collections.emptyListIterator();</span>
      }
<span class="fc" id="L247">      return new CartesianProductIterator&lt;&gt;(dimensions);</span>
    }

    // /**
    // * Get a stream of list items, representing each Cartesian product, based on
    // * this iterator.
    // *
    // * @return a stream of list items representing each Cartesian product
    // */
    // @NonNull
    // public Stream&lt;List&lt;T&gt;&gt; stream() {
    // int characteristics = Spliterator.ORDERED | Spliterator.SIZED |
    // Spliterator.IMMUTABLE;
    // return StreamSupport.stream(Spliterators.spliterator(iterator(), size,
    // characteristics), false);
    // }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>