<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CustomCollectors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.util</a> &gt; <span class="el_source">CustomCollectors.java</span></div><h1>CustomCollectors.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.util;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.umd.cs.findbugs.annotations.NonNull;

@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public final class CustomCollectors {
  /**
   * An implementation of {@link Function#identity()} that respects non-nullness.
   *
   * @param &lt;T&gt;
   *          the Java type of the identity object
   * @return the identity function
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static &lt;T&gt; Function&lt;T, T&gt; identity() {
<span class="fc" id="L34">    return Function.identity();</span>
  }

  /**
   * Joins a sequence of string values using oxford-style serial commas.
   *
   * @param conjunction
   *          the conjunction to use after the penultimate comma (e.g., and, or)
   * @return a collector that will perform the joining
   */
  public static Collector&lt;CharSequence, ?, String&gt; joiningWithOxfordComma(@NonNull String conjunction) {
<span class="fc" id="L45">    return Collectors.collectingAndThen(Collectors.toList(), withOxfordComma(conjunction));</span>
  }

  private static Function&lt;List&lt;CharSequence&gt;, String&gt; withOxfordComma(@NonNull String conjunction) {
<span class="fc" id="L49">    return list -&gt; {</span>
<span class="fc" id="L50">      int size = list.size();</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">      if (size &lt; 2) {</span>
<span class="nc" id="L52">        return String.join(&quot;&quot;, list);</span>
      }
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">      if (size == 2) {</span>
<span class="fc" id="L55">        return String.join(&quot; &quot; + conjunction + &quot; &quot;, list);</span>
      }
      // else there are 3 or more
<span class="nc" id="L58">      int last = size - 1;</span>
<span class="nc" id="L59">      return String.join(&quot;, &quot; + conjunction + &quot; &quot;,</span>
<span class="nc" id="L60">          String.join(&quot;, &quot;, list.subList(0, last)),</span>
<span class="nc" id="L61">          list.get(last));</span>
    };
  }

  /**
   * Produce a new stream with duplicates removed based on the provided
   * {@code keyMapper}. When a duplicate key is encountered, the second item is
   * used. The original sequencing is preserved if the input stream is sequential.
   *
   * @param &lt;V&gt;
   *          the item value for the streams
   * @param &lt;K&gt;
   *          the key type
   * @param stream
   *          the stream to reduce
   * @param keyMapper
   *          the key function to use to find unique items
   * @return a new stream
   */
  public static &lt;V, K&gt; Stream&lt;V&gt; distinctByKey(
      @NonNull Stream&lt;V&gt; stream,
      @NonNull Function&lt;? super V, ? extends K&gt; keyMapper) {
<span class="nc" id="L83">    return distinctByKey(stream, keyMapper, (key, value1, value2) -&gt; value2);</span>
  }

  /**
   * Produce a new stream with duplicates removed based on the provided
   * {@code keyMapper}. When a duplicate key is encountered, the provided
   * {@code duplicateHandler} is used to determine which item to keep. The
   * original sequencing is preserved if the input stream is sequential.
   *
   * @param &lt;V&gt;
   *          the item value for the streams
   * @param &lt;K&gt;
   *          the key type
   * @param stream
   *          the stream to reduce
   * @param keyMapper
   *          the key function to use to find unique items
   * @param duplicateHander
   *          used to determine which of two duplicates to keep
   * @return a new stream
   */
  public static &lt;V, K&gt; Stream&lt;V&gt; distinctByKey(
      @NonNull Stream&lt;V&gt; stream,
      @NonNull Function&lt;? super V, ? extends K&gt; keyMapper,
      @NonNull DuplicateHandler&lt;K, V&gt; duplicateHander) {
<span class="nc" id="L108">    Map&lt;K, V&gt; uniqueRoles = stream</span>
<span class="nc" id="L109">        .collect(toMap(</span>
            keyMapper,
<span class="nc" id="L111">            identity(),</span>
            duplicateHander,
            LinkedHashMap::new));
<span class="nc" id="L114">    return uniqueRoles.values().stream();</span>
  }

  /**
   * Produces a map collector that uses the provided key and value mappers, and a
   * duplicate hander to manage duplicate key insertion.
   *
   * @param &lt;T&gt;
   *          the item Java type
   * @param &lt;K&gt;
   *          the map key Java type
   * @param &lt;V&gt;
   *          the map value Java type
   * @param keyMapper
   *          the function used to produce the map's key based on the provided
   *          item
   * @param valueMapper
   *          the function used to produce the map's value based on the provided
   *          item
   * @param duplicateHander
   *          the handler used to manage duplicate key insertion
   * @return the collector
   */
  @NonNull
  public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, V&gt;&gt; toMap(
      @NonNull Function&lt;? super T, ? extends K&gt; keyMapper,
      @NonNull Function&lt;? super T, ? extends V&gt; valueMapper,
      @NonNull DuplicateHandler&lt;K, V&gt; duplicateHander) {
<span class="fc" id="L142">    return toMap(keyMapper, valueMapper, duplicateHander, HashMap::new);</span>
  }

  /**
   * Produces a map collector that uses the provided key and value mappers, and a
   * duplicate hander to manage duplicate key insertion.
   *
   * @param &lt;T&gt;
   *          the item Java type
   * @param &lt;K&gt;
   *          the map key Java type
   * @param &lt;V&gt;
   *          the map value Java type
   * @param &lt;M&gt;
   *          the Java type of the resulting map
   * @param keyMapper
   *          the function used to produce the map's key based on the provided
   *          item
   * @param valueMapper
   *          the function used to produce the map's value based on the provided
   *          item
   * @param duplicateHander
   *          the handler used to manage duplicate key insertion
   * @param supplier
   *          the supplier used to create the resulting map
   * @return the collector
   */
  @NonNull
  public static &lt;T, K, V, M extends Map&lt;K, V&gt;&gt; Collector&lt;T, ?, M&gt; toMap(
      @NonNull Function&lt;? super T, ? extends K&gt; keyMapper,
      @NonNull Function&lt;? super T, ? extends V&gt; valueMapper,
      @NonNull DuplicateHandler&lt;K, V&gt; duplicateHander,
      Supplier&lt;M&gt; supplier) {
<span class="fc" id="L175">    return ObjectUtils.notNull(</span>
<span class="fc" id="L176">        Collector.of(</span>
            supplier,
            (map, item) -&gt; {
<span class="fc" id="L179">              K key = keyMapper.apply(item);</span>
<span class="fc" id="L180">              V value = Objects.requireNonNull(valueMapper.apply(item));</span>
<span class="fc" id="L181">              V oldValue = map.get(key);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">              if (oldValue != null) {</span>
<span class="fc" id="L183">                value = duplicateHander.handle(key, oldValue, value);</span>
              }
<span class="fc" id="L185">              map.put(key, value);</span>
<span class="fc" id="L186">            },</span>
            (map1, map2) -&gt; {
<span class="nc" id="L188">              map2.forEach((key, value) -&gt; {</span>
<span class="nc" id="L189">                V oldValue = map1.get(key);</span>
<span class="nc" id="L190">                V newValue = value;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (oldValue != null) {</span>
<span class="nc" id="L192">                  newValue = duplicateHander.handle(key, oldValue, value);</span>
                }
<span class="nc" id="L194">                map1.put(key, newValue);</span>
<span class="nc" id="L195">              });</span>
<span class="nc" id="L196">              return map1;</span>
            }));
  }

  /**
   * A handler that supports resolving duplicate keys while inserting values into
   * a map.
   *
   * @param &lt;K&gt;
   *          the Java type of the map's keys
   * @param &lt;V&gt;
   *          the Java type of the map's values
   */
  @FunctionalInterface
  public interface DuplicateHandler&lt;K, V&gt; {
    /**
     * The handler callback.
     *
     * @param key
     *          the duplicate key
     * @param value1
     *          the first value associated with the key
     * @param value2
     *          the second value associated with the key
     * @return the value to insert into the map
     */
    @NonNull
    V handle(K key, @NonNull V value1, V value2);
  }

  /**
   * A binary operator that will always use the first of two values.
   *
   * @param &lt;T&gt;
   *          the item type
   * @return the operator
   */
  @NonNull
  public static &lt;T&gt; BinaryOperator&lt;T&gt; useFirstMapper() {
<span class="nc" id="L235">    return (value1, value2) -&gt; value1;</span>
  }

  /**
   * A binary operator that will always use the second of two values.
   *
   * @param &lt;T&gt;
   *          the item type
   * @return the operator
   */
  @NonNull
  public static &lt;T&gt; BinaryOperator&lt;T&gt; useLastMapper() {
<span class="nc" id="L247">    return (value1, value2) -&gt; value2;</span>
  }

  private CustomCollectors() {
    // disable construction
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>