<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultConstraintValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.constraint</a> &gt; <span class="el_source">DefaultConstraintValidator.java</span></div><h1>DefaultConstraintValidator.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.constraint;

import gov.nist.secauto.metaschema.core.configuration.DefaultConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IMutableConfiguration;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.MetapathException;
import gov.nist.secauto.metaschema.core.metapath.MetapathExpression;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnBoolean;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnData;
import gov.nist.secauto.metaschema.core.metapath.item.node.AbstractNodeItemVisitor;
import gov.nist.secauto.metaschema.core.metapath.item.node.IAssemblyNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDefinitionNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IFieldNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IFlagNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IModuleNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItem;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFieldDefinition;
import gov.nist.secauto.metaschema.core.model.IFlagDefinition;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Used to perform constraint validation over one or more node items.
 * &lt;p&gt;
 * This class is not thread safe.
 */
@SuppressWarnings({
    &quot;PMD.CouplingBetweenObjects&quot;,
    &quot;PMD.GodClass&quot; // provides validators for all types
})
public class DefaultConstraintValidator
    implements IConstraintValidator, IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; { // NOPMD - intentional
<span class="fc" id="L60">  private static final Logger LOGGER = LogManager.getLogger(DefaultConstraintValidator.class);</span>

<span class="fc" id="L62">  @NonNull</span>
  private final Map&lt;INodeItem, ValueStatus&gt; valueMap = new LinkedHashMap&lt;&gt;(); // NOPMD - intentional
<span class="fc" id="L64">  @NonNull</span>
  private final Map&lt;String, IIndex&gt; indexNameToIndexMap = new ConcurrentHashMap&lt;&gt;();
<span class="fc" id="L66">  @NonNull</span>
  private final Map&lt;String, List&lt;KeyRef&gt;&gt; indexNameToKeyRefMap = new ConcurrentHashMap&lt;&gt;();
  @NonNull
  private final IConstraintValidationHandler handler;
  @NonNull
  private final IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; configuration;

  /**
   * Construct a new constraint validator instance.
   *
   * @param handler
   *          the validation handler to use for handling constraint violations
   */
  public DefaultConstraintValidator(
<span class="fc" id="L80">      @NonNull IConstraintValidationHandler handler) {</span>
<span class="fc" id="L81">    this.handler = handler;</span>
<span class="fc" id="L82">    this.configuration = new DefaultConfiguration&lt;&gt;();</span>
<span class="fc" id="L83">  }</span>

  /**
   * Get the current configuration of the serializer/deserializer.
   *
   * @return the configuration
   */
  @NonNull
  protected IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; getConfiguration() {
<span class="fc" id="L92">    return configuration;</span>
  }

  @Override
  public DefaultConstraintValidator enableFeature(ValidationFeature&lt;?&gt; feature) {
<span class="nc" id="L97">    return set(feature, true);</span>
  }

  @Override
  public DefaultConstraintValidator disableFeature(ValidationFeature&lt;?&gt; feature) {
<span class="nc" id="L102">    return set(feature, false);</span>
  }

  @Override
  public DefaultConstraintValidator applyConfiguration(
      @NonNull IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; other) {
<span class="nc" id="L108">    getConfiguration().applyConfiguration(other);</span>
<span class="nc" id="L109">    return this;</span>
  }

  @Override
  public DefaultConstraintValidator set(ValidationFeature&lt;?&gt; feature, Object value) {
<span class="nc" id="L114">    getConfiguration().set(feature, value);</span>
<span class="nc" id="L115">    return this;</span>
  }

  @Override
  public boolean isFeatureEnabled(ValidationFeature&lt;?&gt; feature) {
<span class="fc" id="L120">    return getConfiguration().isFeatureEnabled(feature);</span>
  }

  @Override
  public Map&lt;ValidationFeature&lt;?&gt;, Object&gt; getFeatureValues() {
<span class="nc" id="L125">    return getConfiguration().getFeatureValues();</span>
  }

  /**
   * Get the validation handler to use for handling constraint violations.
   *
   * @return the handler
   */
  @NonNull
  protected IConstraintValidationHandler getConstraintValidationHandler() {
<span class="fc" id="L135">    return handler;</span>
  }

  @Override
  public void validate(
      @NonNull INodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L142">    item.accept(new Visitor(), dynamicContext);</span>
<span class="fc" id="L143">  }</span>

  /**
   * Validate the provided flag item against any associated constraints.
   *
   * @param item
   *          the flag item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateFlag(
      @NonNull IFlagNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L160">    IFlagDefinition definition = item.getDefinition();</span>

<span class="fc" id="L162">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="fc" id="L163">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="fc" id="L164">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="fc" id="L165">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="fc" id="L166">  }</span>

  /**
   * Validate the provided field item against any associated constraints.
   *
   * @param item
   *          the field item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateField(
      @NonNull IFieldNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L183">    IFieldDefinition definition = item.getDefinition();</span>

<span class="nc" id="L185">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="nc" id="L186">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L187">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="nc" id="L188">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L189">  }</span>

  /**
   * Validate the provided assembly item against any associated constraints.
   *
   * @param item
   *          the assembly item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateAssembly(
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L206">    IAssemblyDefinition definition = item.getDefinition();</span>

<span class="nc" id="L208">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="nc" id="L209">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L210">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="nc" id="L211">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L212">    validateHasCardinality(definition.getHasCardinalityConstraints(), item, dynamicContext);</span>
<span class="nc" id="L213">    validateIndex(definition.getIndexConstraints(), item, dynamicContext);</span>
<span class="nc" id="L214">    validateUnique(definition.getUniqueConstraints(), item, dynamicContext);</span>
<span class="nc" id="L215">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateHasCardinality( // NOPMD false positive
      @NonNull List&lt;? extends ICardinalityConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">    for (ICardinalityConstraint constraint : constraints) {</span>
<span class="nc" id="L234">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
      try {
<span class="nc" id="L236">        validateHasCardinality(constraint, item, targets);</span>
<span class="nc" id="L237">      } catch (MetapathException ex) {</span>
<span class="nc" id="L238">        handleError(constraint, item, ex);</span>
<span class="nc" id="L239">      }</span>
<span class="nc" id="L240">    }</span>
<span class="nc" id="L241">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateHasCardinality(
      @NonNull ICardinalityConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets) {
<span class="nc" id="L260">    int itemCount = targets.size();</span>

<span class="nc" id="L262">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>

<span class="nc" id="L264">    boolean violation = false;</span>
<span class="nc" id="L265">    Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L266" title="All 4 branches missed.">    if (minOccurs != null &amp;&amp; itemCount &lt; minOccurs) {</span>
<span class="nc" id="L267">      handler.handleCardinalityMinimumViolation(constraint, node, targets);</span>
<span class="nc" id="L268">      violation = true;</span>
    }

<span class="nc" id="L271">    Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">    if (maxOccurs != null &amp;&amp; itemCount &gt; maxOccurs) {</span>
<span class="nc" id="L273">      handler.handleCardinalityMaximumViolation(constraint, node, targets);</span>
<span class="nc" id="L274">      violation = true;</span>
    }

<span class="nc bnc" id="L277" title="All 2 branches missed.">    if (!violation) {</span>
<span class="nc" id="L278">      handlePass(constraint, node, node);</span>
    }
<span class="nc" id="L280">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateIndex(
      @NonNull List&lt;? extends IIndexConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">    for (IIndexConstraint constraint : constraints) {</span>
<span class="nc" id="L299">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
      try {
<span class="nc" id="L301">        validateIndex(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L302">      } catch (MetapathException ex) {</span>
<span class="nc" id="L303">        handleError(constraint, item, ex);</span>
<span class="nc" id="L304">      }</span>
<span class="nc" id="L305">    }</span>
<span class="nc" id="L306">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateIndex(
      @NonNull IIndexConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L329">    String indexName = constraint.getName();</span>

<span class="nc" id="L331">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">    if (indexNameToIndexMap.containsKey(indexName)) {</span>
<span class="nc" id="L333">      handler.handleIndexDuplicateViolation(constraint, node);</span>
    } else {
<span class="nc" id="L335">      IIndex index = IIndex.newInstance(constraint.getKeyFields());</span>
<span class="nc" id="L336">      targets.stream()</span>
<span class="nc" id="L337">          .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            assert item != null;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (item.hasValue()) {</span>
              try {
<span class="nc" id="L341">                INodeItem oldItem = index.put(item, dynamicContext);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (oldItem == null) {</span>
<span class="nc" id="L343">                  handlePass(constraint, node, item);</span>
                } else {
<span class="nc" id="L345">                  handler.handleIndexDuplicateKeyViolation(constraint, node, oldItem, item);</span>
                }
<span class="nc" id="L347">              } catch (MetapathException ex) {</span>
<span class="nc" id="L348">                handler.handleKeyMatchError(constraint, node, item, ex);</span>
<span class="nc" id="L349">              }</span>
            }
<span class="nc" id="L351">          });</span>
<span class="nc" id="L352">      indexNameToIndexMap.put(indexName, index);</span>
    }
<span class="nc" id="L354">  }</span>

  private void handlePass(
      @NonNull IConstraint constraint,
      @NonNull INodeItem node,
      @NonNull INodeItem item) {
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">    if (isFeatureEnabled(ValidationFeature.VALIDATE_GENERATE_PASS_FINDINGS)) {</span>
<span class="nc" id="L361">      getConstraintValidationHandler().handlePass(constraint, node, item);</span>
    }
<span class="fc" id="L363">  }</span>

  private void handleError(
      @NonNull IConstraint constraint,
      @NonNull INodeItem node,
      @NonNull MetapathException ex) {
<span class="nc" id="L369">    getConstraintValidationHandler().handleError(constraint, node, toErrorMessage(constraint, node, ex), ex);</span>
<span class="nc" id="L370">  }</span>

  @NonNull
  private static String toErrorMessage(
      @NonNull IConstraint constraint,
      @NonNull INodeItem item,
      @NonNull MetapathException ex) {
<span class="nc" id="L377">    StringBuilder builder = new StringBuilder(128);</span>
<span class="nc" id="L378">    builder.append(&quot;A &quot;)</span>
<span class="nc" id="L379">        .append(constraint.getClass().getName())</span>
<span class="nc" id="L380">        .append(&quot; constraint&quot;);</span>

<span class="nc" id="L382">    String id = constraint.getId();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (id == null) {</span>
<span class="nc" id="L384">      builder.append(&quot; targeting the metapath '&quot;)</span>
<span class="nc" id="L385">          .append(constraint.getTarget())</span>
<span class="nc" id="L386">          .append('\'');</span>
    } else {
<span class="nc" id="L388">      builder.append(&quot; with id '&quot;)</span>
<span class="nc" id="L389">          .append(id)</span>
<span class="nc" id="L390">          .append('\'');</span>
    }

<span class="nc" id="L393">    builder.append(&quot;, matching the item at path '&quot;)</span>
<span class="nc" id="L394">        .append(item.getMetapath())</span>
<span class="nc" id="L395">        .append(&quot;', resulted in an unexpected error. The error was: &quot;)</span>
<span class="nc" id="L396">        .append(ex.getLocalizedMessage());</span>
<span class="nc" id="L397">    return ObjectUtils.notNull(builder.toString());</span>
  }

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateUnique(
      @NonNull List&lt;? extends IUniqueConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L416" title="All 2 branches missed.">    for (IUniqueConstraint constraint : constraints) {</span>
<span class="nc" id="L417">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
      try {
<span class="nc" id="L419">        validateUnique(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L420">      } catch (MetapathException ex) {</span>
<span class="nc" id="L421">        handleError(constraint, item, ex);</span>
<span class="nc" id="L422">      }</span>
<span class="nc" id="L423">    }</span>
<span class="nc" id="L424">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateUnique(
      @NonNull IUniqueConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {

<span class="nc" id="L448">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L449">    IIndex index = IIndex.newInstance(constraint.getKeyFields());</span>
<span class="nc" id="L450">    targets.stream()</span>
<span class="nc" id="L451">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">          assert item != null;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">          if (item.hasValue()) {</span>
            try {
<span class="nc" id="L455">              INodeItem oldItem = index.put(item, dynamicContext);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">              if (oldItem == null) {</span>
<span class="nc" id="L457">                handlePass(constraint, node, item);</span>
              } else {
<span class="nc" id="L459">                handler.handleUniqueKeyViolation(constraint, node, oldItem, item);</span>
              }
<span class="nc" id="L461">            } catch (MetapathException ex) {</span>
<span class="nc" id="L462">              handler.handleKeyMatchError(constraint, node, item, ex);</span>
<span class="nc" id="L463">              throw ex;</span>
<span class="nc" id="L464">            }</span>
          }
<span class="nc" id="L466">        });</span>
<span class="nc" id="L467">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateMatches( // NOPMD false positive
      @NonNull List&lt;? extends IMatchesConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">    for (IMatchesConstraint constraint : constraints) {</span>
<span class="nc" id="L487">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
      try {
<span class="nc" id="L489">        validateMatches(constraint, item, targets);</span>
<span class="nc" id="L490">      } catch (MetapathException ex) {</span>
<span class="nc" id="L491">        handleError(constraint, item, ex);</span>
<span class="nc" id="L492">      }</span>
<span class="nc" id="L493">    }</span>
<span class="fc" id="L494">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateMatches(
      @NonNull IMatchesConstraint constraint,
      @NonNull INodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets) {
<span class="nc" id="L513">    targets.stream()</span>
<span class="nc" id="L514">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">          assert item != null;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">          if (item.hasValue()) {</span>
<span class="nc" id="L517">            validateMatchesItem(constraint, node, item);</span>
          }
<span class="nc" id="L519">        });</span>
<span class="nc" id="L520">  }</span>

  private void validateMatchesItem(
      @NonNull IMatchesConstraint constraint,
      @NonNull INodeItem node,
      @NonNull INodeItem item) {
<span class="nc" id="L526">    String value = FnData.fnDataItem(item).asString();</span>

<span class="nc" id="L528">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L529">    boolean valid = true;</span>
<span class="nc" id="L530">    Pattern pattern = constraint.getPattern();</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">    if (pattern != null &amp;&amp; !pattern.asMatchPredicate().test(value)) {</span>
      // failed pattern match
<span class="nc" id="L533">      handler.handleMatchPatternViolation(constraint, node, item, value, pattern);</span>
<span class="nc" id="L534">      valid = false;</span>
    }

<span class="nc" id="L537">    IDataTypeAdapter&lt;?&gt; adapter = constraint.getDataType();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">    if (adapter != null) {</span>
      try {
<span class="nc" id="L540">        adapter.parse(value);</span>
<span class="nc" id="L541">      } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L542">        handler.handleMatchDatatypeViolation(constraint, node, item, value, adapter, ex);</span>
<span class="nc" id="L543">        valid = false;</span>
<span class="nc" id="L544">      }</span>
    }

<span class="nc bnc" id="L547" title="All 2 branches missed.">    if (valid) {</span>
<span class="nc" id="L548">      handlePass(constraint, node, item);</span>
    }
<span class="nc" id="L550">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateIndexHasKey( // NOPMD false positive
      @NonNull List&lt;? extends IIndexHasKeyConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {

<span class="pc bpc" id="L569" title="1 of 2 branches missed.">    for (IIndexHasKeyConstraint constraint : constraints) {</span>
<span class="nc" id="L570">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L571">      validateIndexHasKey(constraint, item, targets);</span>
<span class="nc" id="L572">    }</span>
<span class="fc" id="L573">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateIndexHasKey(
      @NonNull IIndexHasKeyConstraint constraint,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets) {
<span class="nc" id="L592">    String indexName = constraint.getIndexName();</span>

<span class="nc" id="L594">    List&lt;KeyRef&gt; keyRefItems = indexNameToKeyRefMap.get(indexName);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">    if (keyRefItems == null) {</span>
<span class="nc" id="L596">      keyRefItems = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L597">      indexNameToKeyRefMap.put(indexName, keyRefItems);</span>
    }

<span class="nc" id="L600">    KeyRef keyRef = new KeyRef(constraint, node, new ArrayList&lt;&gt;(targets.getValue()));</span>
<span class="nc" id="L601">    keyRefItems.add(keyRef);</span>
<span class="nc" id="L602">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateExpect(
      @NonNull List&lt;? extends IExpectConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">    for (IExpectConstraint constraint : constraints) {</span>
<span class="nc" id="L621">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L622">      validateExpect(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L623">    }</span>
<span class="fc" id="L624">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateExpect(
      @NonNull IExpectConstraint constraint,
      @NonNull INodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L647">    MetapathExpression metapath = MetapathExpression.compile(</span>
<span class="nc" id="L648">        constraint.getTest(),</span>
<span class="nc" id="L649">        dynamicContext.getStaticContext());</span>

<span class="nc" id="L651">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L652">    targets.stream()</span>
<span class="nc" id="L653">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">          assert item != null;</span>

<span class="nc bnc" id="L656" title="All 2 branches missed.">          if (item.hasValue()) {</span>
            try {
<span class="nc" id="L658">              ISequence&lt;?&gt; result = metapath.evaluate(item, dynamicContext);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">              if (FnBoolean.fnBoolean(result).toBoolean()) {</span>
<span class="nc" id="L660">                handlePass(constraint, node, item);</span>
              } else {
<span class="nc" id="L662">                handler.handleExpectViolation(constraint, node, item, dynamicContext);</span>
              }
<span class="nc" id="L664">            } catch (MetapathException ex) {</span>
<span class="nc" id="L665">              handleError(constraint, item, ex);</span>
<span class="nc" id="L666">            }</span>
          }
<span class="nc" id="L668">        });</span>
<span class="nc" id="L669">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateAllowedValues(
      @NonNull List&lt;? extends IAllowedValuesConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc bfc" id="L687" title="All 2 branches covered.">    for (IAllowedValuesConstraint constraint : constraints) {</span>
<span class="fc" id="L688">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="fc" id="L689">      validateAllowedValues(constraint, item, targets);</span>
<span class="fc" id="L690">    }</span>
<span class="fc" id="L691">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateAllowedValues(
      @NonNull IAllowedValuesConstraint constraint,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node,
      @NonNull ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets) {
<span class="fc" id="L710">    targets.stream().forEachOrdered(item -&gt; {</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">      assert item != null;</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">      if (item.hasValue()) {</span>
        try {
<span class="fc" id="L714">          updateValueStatus(item, constraint, node);</span>
<span class="nc" id="L715">        } catch (MetapathException ex) {</span>
<span class="nc" id="L716">          handleError(constraint, item, ex);</span>
<span class="fc" id="L717">        }</span>
      }
<span class="fc" id="L719">    });</span>
<span class="fc" id="L720">  }</span>

  /**
   * Add a new allowed value to the value status tracker.
   *
   * @param targetItem
   *          the item whose value is targeted by the constraint
   * @param allowedValues
   *          the allowed values constraint
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   */
  protected void updateValueStatus(
      @NonNull INodeItem targetItem,
      @NonNull IAllowedValuesConstraint allowedValues,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node) {
    // constraint.getAllowedValues().containsKey(value)

<span class="fc" id="L739">    @Nullable ValueStatus valueStatus = valueMap.get(targetItem);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">    if (valueStatus == null) {</span>
<span class="fc" id="L741">      valueStatus = new ValueStatus(targetItem);</span>
<span class="fc" id="L742">      valueMap.put(targetItem, valueStatus);</span>
    }

<span class="fc" id="L745">    valueStatus.registerAllowedValue(allowedValues, node);</span>
<span class="fc" id="L746">  }</span>

  /**
   * Evaluate the value associated with the {@code targetItem} and update the
   * status tracker.
   *
   * @param targetItem
   *          the item whose value will be validated
   */
  protected void handleAllowedValues(@NonNull INodeItem targetItem) {
<span class="fc" id="L756">    ValueStatus valueStatus = valueMap.remove(targetItem);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">    if (valueStatus != null) {</span>
<span class="fc" id="L758">      valueStatus.validate();</span>
    }
<span class="fc" id="L760">  }</span>

  @Override
  public void finalizeValidation(DynamicContext dynamicContext) {
    // key references
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">    for (Map.Entry&lt;String, List&lt;KeyRef&gt;&gt; entry : indexNameToKeyRefMap.entrySet()) {</span>
<span class="nc" id="L766">      String indexName = ObjectUtils.notNull(entry.getKey());</span>
<span class="nc" id="L767">      IIndex index = indexNameToIndexMap.get(indexName);</span>

<span class="nc" id="L769">      List&lt;KeyRef&gt; keyRefs = entry.getValue();</span>

<span class="nc bnc" id="L771" title="All 2 branches missed.">      for (KeyRef keyRef : keyRefs) {</span>
<span class="nc" id="L772">        IIndexHasKeyConstraint constraint = keyRef.getConstraint();</span>

<span class="nc" id="L774">        INodeItem node = keyRef.getNode();</span>
<span class="nc" id="L775">        List&lt;INodeItem&gt; targets = keyRef.getTargets();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">        for (INodeItem item : targets) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">          assert item != null;</span>

<span class="nc" id="L779">          validateKeyRef(constraint, node, item, indexName, index, dynamicContext);</span>
<span class="nc" id="L780">        }</span>
<span class="nc" id="L781">      }</span>
<span class="nc" id="L782">    }</span>
<span class="fc" id="L783">  }</span>

  private void validateKeyRef(
      @NonNull IIndexHasKeyConstraint constraint,
      @NonNull INodeItem contextNode,
      @NonNull INodeItem item,
      @NonNull String indexName,
      @Nullable IIndex index,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L792">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
    try {
<span class="nc" id="L794">      List&lt;String&gt; key = IIndex.toKey(item, constraint.getKeyFields(), dynamicContext);</span>

<span class="nc bnc" id="L796" title="All 2 branches missed.">      if (index == null) {</span>
<span class="nc" id="L797">        handler.handleMissingIndexViolation(constraint, contextNode, item, ObjectUtils.notNull(</span>
<span class="nc" id="L798">            String.format(&quot;Key reference to undefined index with name '%s'&quot;, indexName)));</span>
      } else {
<span class="nc" id="L800">        INodeItem referencedItem = index.get(key);</span>

<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (referencedItem == null) {</span>
<span class="nc" id="L803">          handler.handleIndexMiss(constraint, contextNode, item, key);</span>
        } else {
<span class="nc" id="L805">          handlePass(constraint, contextNode, item);</span>
        }
      }
<span class="nc" id="L808">    } catch (MetapathException ex) {</span>
<span class="nc" id="L809">      handler.handleKeyMatchError(constraint, contextNode, item, ex);</span>
<span class="nc" id="L810">    }</span>
<span class="nc" id="L811">  }</span>

  private class ValueStatus {
<span class="fc" id="L814">    @NonNull</span>
    private final List&lt;Pair&lt;IAllowedValuesConstraint, IDefinitionNodeItem&lt;?, ?&gt;&gt;&gt; constraints = new LinkedList&lt;&gt;();
    @NonNull
    private final String value;
    @NonNull
    private final INodeItem item;
<span class="fc" id="L820">    private boolean allowOthers = true;</span>
<span class="fc" id="L821">    @NonNull</span>
    private IAllowedValuesConstraint.Extensible extensible = IAllowedValuesConstraint.Extensible.EXTERNAL;

<span class="fc" id="L824">    public ValueStatus(@NonNull INodeItem item) {</span>
<span class="fc" id="L825">      this.item = item;</span>
<span class="fc" id="L826">      this.value = FnData.fnDataItem(item).asString();</span>
<span class="fc" id="L827">    }</span>

    public void registerAllowedValue(
        @NonNull IAllowedValuesConstraint allowedValues,
        @NonNull IDefinitionNodeItem&lt;?, ?&gt; node) {
<span class="fc" id="L832">      this.constraints.add(Pair.of(allowedValues, node));</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">      if (!allowedValues.isAllowedOther()) {</span>
        // record the most restrictive value
<span class="fc" id="L835">        allowOthers = false;</span>
      }

<span class="fc" id="L838">      IAllowedValuesConstraint.Extensible newExtensible = allowedValues.getExtensible();</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">      if (newExtensible.ordinal() &gt; extensible.ordinal()) {</span>
        // record the most restrictive value
<span class="nc" id="L841">        extensible = allowedValues.getExtensible();</span>
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">      } else if (IAllowedValuesConstraint.Extensible.NONE.equals(newExtensible)</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">          &amp;&amp; IAllowedValuesConstraint.Extensible.NONE.equals(extensible)) {</span>
        // this is an error, where there are two none constraints that conflict
<span class="nc" id="L845">        throw new MetapathException(</span>
<span class="nc" id="L846">            String.format(&quot;Multiple constraints have extensibility scope=none at path '%s'&quot;, item.getMetapath()));</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">      } else if (allowedValues.getExtensible().ordinal() &lt; extensible.ordinal()) {</span>
<span class="nc" id="L848">        String msg = String.format(</span>
            &quot;An allowed values constraint with an extensibility scope '%s'&quot;
                + &quot; exceeds the allowed scope '%s' at path '%s'&quot;,
<span class="nc" id="L851">            allowedValues.getExtensible().name(), extensible.name(), item.getMetapath());</span>
<span class="nc" id="L852">        LOGGER.atError().log(msg);</span>
<span class="nc" id="L853">        throw new MetapathException(msg);</span>
      }
<span class="fc" id="L855">    }</span>

    public void validate() {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">      if (!constraints.isEmpty()) {</span>
<span class="fc" id="L859">        boolean match = false;</span>
<span class="fc" id="L860">        List&lt;IAllowedValuesConstraint&gt; failedConstraints = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L861">        IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">        for (Pair&lt;IAllowedValuesConstraint, IDefinitionNodeItem&lt;?, ?&gt;&gt; pair : constraints) {</span>
<span class="fc" id="L863">          IAllowedValuesConstraint allowedValues = pair.getLeft();</span>
<span class="fc" id="L864">          IDefinitionNodeItem&lt;?, ?&gt; node = ObjectUtils.notNull(pair.getRight());</span>
<span class="fc" id="L865">          IAllowedValue matchingValue = allowedValues.getAllowedValue(value);</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">          if (matchingValue != null) {</span>
<span class="fc" id="L867">            match = true;</span>
<span class="fc" id="L868">            handlePass(allowedValues, node, item);</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">          } else if (IAllowedValuesConstraint.Extensible.NONE.equals(allowedValues.getExtensible())) {</span>
            // hard failure, since no other values can satisfy this constraint
<span class="nc" id="L871">            failedConstraints = CollectionUtil.singletonList(allowedValues);</span>
<span class="nc" id="L872">            match = false;</span>
<span class="nc" id="L873">            break;</span>
          } else {
<span class="fc" id="L875">            failedConstraints.add(allowedValues);</span>
          } // this constraint passes, but we need to make sure other constraints do as well
<span class="fc" id="L877">        }</span>

        // it's not a failure if allow others is true
<span class="fc bfc" id="L880" title="All 4 branches covered.">        if (!match &amp;&amp; !allowOthers) {</span>
<span class="fc" id="L881">          handler.handleAllowedValuesViolation(failedConstraints, item);</span>
        }
      }
<span class="fc" id="L884">    }</span>
  }

<span class="fc" id="L887">  class Visitor</span>
      extends AbstractNodeItemVisitor&lt;DynamicContext, Void&gt; {

    @NonNull
    private DynamicContext handleLetStatements(
        @NonNull INodeItem focus,
        @NonNull Map&lt;QName, ILet&gt; letExpressions,
        @NonNull DynamicContext dynamicContext) {

      DynamicContext retval;
<span class="fc" id="L897">      Collection&lt;ILet&gt; lets = letExpressions.values();</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">      if (lets.isEmpty()) {</span>
<span class="fc" id="L899">        retval = dynamicContext;</span>
      } else {
<span class="nc" id="L901">        final DynamicContext subContext = dynamicContext.subContext();</span>

<span class="nc bnc" id="L903" title="All 2 branches missed.">        for (ILet let : lets) {</span>
<span class="nc" id="L904">          QName name = let.getName();</span>
<span class="nc" id="L905">          ISequence&lt;?&gt; result = let.getValueExpression().evaluate(focus, subContext);</span>

          // ensure the sequence is list backed
<span class="nc" id="L908">          result.getValue();</span>

<span class="nc" id="L910">          subContext.bindVariableValue(name, result);</span>
<span class="nc" id="L911">        }</span>
<span class="nc" id="L912">        retval = subContext;</span>
      }
<span class="fc" id="L914">      return retval;</span>
    }

    @Override
    public Void visitFlag(@NonNull IFlagNodeItem item, DynamicContext context) {
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">      assert context != null;</span>

<span class="fc" id="L921">      IFlagDefinition definition = item.getDefinition();</span>
<span class="fc" id="L922">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="fc" id="L924">      validateFlag(item, effectiveContext);</span>
<span class="fc" id="L925">      super.visitFlag(item, effectiveContext);</span>
<span class="fc" id="L926">      handleAllowedValues(item);</span>
<span class="fc" id="L927">      return null;</span>
    }

    @Override
    public Void visitField(@NonNull IFieldNodeItem item, DynamicContext context) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">      assert context != null;</span>

<span class="nc" id="L934">      IFieldDefinition definition = item.getDefinition();</span>
<span class="nc" id="L935">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="nc" id="L937">      validateField(item, effectiveContext);</span>
<span class="nc" id="L938">      super.visitField(item, effectiveContext);</span>
<span class="nc" id="L939">      handleAllowedValues(item);</span>
<span class="nc" id="L940">      return null;</span>
    }

    @Override
    public Void visitAssembly(@NonNull IAssemblyNodeItem item, DynamicContext context) {
<span class="nc bnc" id="L945" title="All 2 branches missed.">      assert context != null;</span>

<span class="nc" id="L947">      IAssemblyDefinition definition = item.getDefinition();</span>
<span class="nc" id="L948">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="nc" id="L950">      validateAssembly(item, effectiveContext);</span>
<span class="nc" id="L951">      super.visitAssembly(item, effectiveContext);</span>
<span class="nc" id="L952">      return null;</span>
    }

    @Override
    public Void visitMetaschema(@NonNull IModuleNodeItem item, DynamicContext context) {
<span class="nc" id="L957">      throw new UnsupportedOperationException(&quot;not needed&quot;);</span>
    }

    @Override
    protected Void defaultResult() {
      // no result value
<span class="fc" id="L963">      return null;</span>
    }
  }

  private static class KeyRef {
    @NonNull
    private final IIndexHasKeyConstraint constraint;
    @NonNull
    private final INodeItem node;
    @NonNull
    private final List&lt;INodeItem&gt; targets;

    public KeyRef(
        @NonNull IIndexHasKeyConstraint constraint,
        @NonNull INodeItem node,
<span class="nc" id="L978">        @NonNull List&lt;INodeItem&gt; targets) {</span>
<span class="nc" id="L979">      this.node = node;</span>
<span class="nc" id="L980">      this.constraint = constraint;</span>
<span class="nc" id="L981">      this.targets = targets;</span>
<span class="nc" id="L982">    }</span>

    @NonNull
    public IIndexHasKeyConstraint getConstraint() {
<span class="nc" id="L986">      return constraint;</span>
    }

    @NonNull
    protected INodeItem getNode() {
<span class="nc" id="L991">      return node;</span>
    }

    @NonNull
    public List&lt;INodeItem&gt; getTargets() {
<span class="nc" id="L996">      return targets;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>