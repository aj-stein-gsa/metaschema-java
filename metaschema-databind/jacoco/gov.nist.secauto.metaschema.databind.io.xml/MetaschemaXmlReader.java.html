<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaschemaXmlReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.io.xml</a> &gt; <span class="el_source">MetaschemaXmlReader.java</span></div><h1>MetaschemaXmlReader.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.io.xml;

import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.util.XmlEventUtil;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.io.BindingException;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundFieldValue;
import gov.nist.secauto.metaschema.databind.model.IBoundInstance;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceFlag;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModel;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldScalar;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedField;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedNamed;
import gov.nist.secauto.metaschema.databind.model.info.AbstractModelInstanceReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IFeatureScalarItemValueHandler;
import gov.nist.secauto.metaschema.databind.model.info.IItemReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IModelInstanceCollectionInfo;

import org.codehaus.stax2.XMLEventReader2;

import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

<span class="fc" id="L57">public class MetaschemaXmlReader</span>
    implements IXmlParsingContext {
  @NonNull
  private final XMLEventReader2 reader;
  @NonNull
  private final IXmlProblemHandler problemHandler;

  /**
   * Construct a new Module-aware XML parser using the default problem handler.
   *
   * @param reader
   *          the XML reader to parse with
   * @see DefaultXmlProblemHandler
   */
  public MetaschemaXmlReader(
      @NonNull XMLEventReader2 reader) {
<span class="fc" id="L73">    this(reader, new DefaultXmlProblemHandler());</span>
<span class="fc" id="L74">  }</span>

  public &lt;ITEM&gt; ITEM readItem(
      @NonNull IBoundObject item,
      @NonNull IBoundInstance&lt;ITEM&gt; instance,
      @NonNull StartElement start) throws IOException {
<span class="nc" id="L80">    return instance.readItem(item, new ItemReadHandler(start));</span>
  }

  /**
   * Construct a new Module-aware parser.
   *
   * @param reader
   *          the XML reader to parse with
   * @param problemHandler
   *          the problem handler implementation to use
   */
  public MetaschemaXmlReader(
      @NonNull XMLEventReader2 reader,
<span class="fc" id="L93">      @NonNull IXmlProblemHandler problemHandler) {</span>
<span class="fc" id="L94">    this.reader = reader;</span>
<span class="fc" id="L95">    this.problemHandler = problemHandler;</span>
<span class="fc" id="L96">  }</span>

  @Override
  public XMLEventReader2 getReader() {
<span class="fc" id="L100">    return reader;</span>
  }

  @Override
  public IXmlProblemHandler getProblemHandler() {
<span class="fc" id="L105">    return problemHandler;</span>
  }

  /**
   * Parses XML into a bound object based on the provided {@code definition}.
   * &lt;p&gt;
   * Parses the {@link XMLStreamConstants#START_DOCUMENT}, any processing
   * instructions, and the element.
   *
   * @param &lt;CLASS&gt;
   *          the returned object type
   * @param definition
   *          the definition describing the element data to read
   * @return the parsed object
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  @Override
  @NonNull
  public &lt;CLASS&gt; CLASS read(@NonNull IBoundDefinitionModelComplex definition) throws IOException {
    try {
      // we may be at the START_DOCUMENT
<span class="fc bfc" id="L127" title="All 2 branches covered.">      if (reader.peek().isStartDocument()) {</span>
<span class="fc" id="L128">        XmlEventUtil.consumeAndAssert(reader, XMLStreamConstants.START_DOCUMENT);</span>
      }

      // advance past any other info to get to next start element
<span class="fc" id="L132">      XmlEventUtil.skipEvents(reader, XMLStreamConstants.CHARACTERS, XMLStreamConstants.PROCESSING_INSTRUCTION,</span>
          XMLStreamConstants.DTD);

<span class="fc" id="L135">      XMLEvent event = ObjectUtils.requireNonNull(reader.peek());</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">      if (!event.isStartElement()) {</span>
<span class="nc" id="L137">        throw new IOException(</span>
<span class="nc" id="L138">            String.format(&quot;The token '%s' is not an XML element%s.&quot;,</span>
<span class="nc" id="L139">                XmlEventUtil.toEventName(event),</span>
<span class="nc" id="L140">                XmlEventUtil.generateLocationMessage(event)));</span>
      }

<span class="fc" id="L143">      ItemReadHandler handler = new ItemReadHandler(ObjectUtils.notNull(event.asStartElement()));</span>
<span class="fc" id="L144">      return ObjectUtils.asType(definition.readItem(null, handler));</span>
<span class="nc" id="L145">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L146">      throw new IOException(ex);</span>
    }
  }

  /**
   * Read the XML attribute data described by the {@code targetDefinition} and
   * apply it to the provided {@code targetObject}.
   *
   * @param targetDefinition
   *          the Module definition that describes the syntax of the data to read
   * @param targetObject
   *          the Java object that data parsed by this method will be stored in
   * @param start
   *          the containing XML element that was previously parsed
   * @throws IOException
   *           if an error occurred while parsing the input
   * @throws XMLStreamException
   *           if an error occurred while parsing XML events
   */
  protected void readFlagInstances(
      @NonNull IBoundDefinitionModelComplex targetDefinition,
      @NonNull IBoundObject targetObject,
      @NonNull StartElement start) throws IOException, XMLStreamException {

<span class="fc" id="L170">    Map&lt;QName, IBoundInstanceFlag&gt; flagInstanceMap = targetDefinition.getFlagInstances().stream()</span>
<span class="fc" id="L171">        .collect(Collectors.toMap(</span>
            IBoundInstanceFlag::getXmlQName,
<span class="fc" id="L173">            Function.identity()));</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">    for (Attribute attribute : CollectionUtil.toIterable(ObjectUtils.notNull(start.getAttributes()))) {</span>
<span class="fc" id="L176">      QName qname = attribute.getName();</span>
<span class="fc" id="L177">      IBoundInstanceFlag instance = flagInstanceMap.get(qname);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">      if (instance == null) {</span>
        // unrecognized flag
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (!getProblemHandler().handleUnknownAttribute(targetDefinition, targetObject, attribute, this)) {</span>
<span class="nc" id="L181">          throw new IOException(</span>
<span class="nc" id="L182">              String.format(&quot;Unrecognized attribute '%s'%s.&quot;,</span>
                  qname,
<span class="nc" id="L184">                  XmlEventUtil.generateLocationMessage(attribute)));</span>
        }
      } else {
        // get the attribute value
<span class="fc" id="L188">        Object value = instance.getDefinition().getJavaTypeAdapter().parse(ObjectUtils.notNull(attribute.getValue()));</span>
        // apply the value to the parentObject
<span class="fc" id="L190">        instance.setValue(targetObject, value);</span>
<span class="fc" id="L191">        flagInstanceMap.remove(qname);</span>
      }
<span class="fc" id="L193">    }</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (!flagInstanceMap.isEmpty()) {</span>
<span class="fc" id="L196">      getProblemHandler().handleMissingFlagInstances(</span>
          targetDefinition,
          targetObject,
<span class="fc" id="L199">          ObjectUtils.notNull(flagInstanceMap.values()));</span>
    }
<span class="fc" id="L201">  }</span>

  /**
   * Read the XML element data described by the {@code targetDefinition} and apply
   * it to the provided {@code targetObject}.
   *
   * @param targetDefinition
   *          the Module definition that describes the syntax of the data to read
   * @param targetObject
   *          the Java object that data parsed by this method will be stored in
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  protected void readModelInstances(
      @NonNull IBoundDefinitionModelAssembly targetDefinition,
      @NonNull IBoundObject targetObject)
      throws IOException {
<span class="fc" id="L218">    Collection&lt;? extends IBoundInstanceModel&lt;?&gt;&gt; instances = targetDefinition.getModelInstances();</span>
<span class="fc" id="L219">    Set&lt;IBoundInstanceModel&lt;?&gt;&gt; unhandledProperties = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    for (IBoundInstanceModel&lt;?&gt; modelInstance : instances) {</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">      assert modelInstance != null;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      if (!readItems(modelInstance, targetObject, true)) {</span>
<span class="fc" id="L223">        unhandledProperties.add(modelInstance);</span>
      }
<span class="fc" id="L225">    }</span>

    // process all properties that did not get a value
<span class="fc" id="L228">    getProblemHandler().handleMissingModelInstances(targetDefinition, targetObject, unhandledProperties);</span>

    // handle any
    try {
<span class="fc bfc" id="L232" title="All 2 branches covered.">      if (!getReader().peek().isEndElement()) {</span>
        // handle any
<span class="fc" id="L234">        XmlEventUtil.skipWhitespace(getReader());</span>
<span class="fc" id="L235">        XmlEventUtil.skipElement(getReader());</span>
<span class="fc" id="L236">        XmlEventUtil.skipWhitespace(getReader());</span>
      }

<span class="fc" id="L239">      XmlEventUtil.assertNext(getReader(), XMLStreamConstants.END_ELEMENT);</span>
<span class="nc" id="L240">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L241">      throw new IOException(ex);</span>
<span class="fc" id="L242">    }</span>
<span class="fc" id="L243">  }</span>

  /**
   * Determine if the next data to read corresponds to the next model instance.
   *
   * @param targetInstance
   *          the model instance that describes the syntax of the data to read
   * @return {@code true} if the Module instance needs to be parsed, or
   *         {@code false} otherwise
   * @throws XMLStreamException
   *           if an error occurred while parsing XML events
   */
  @SuppressWarnings(&quot;PMD.OnlyOneReturn&quot;)
  protected boolean isNextInstance(
      @NonNull IBoundInstanceModel&lt;?&gt; targetInstance)
      throws XMLStreamException {

<span class="fc" id="L260">    XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc" id="L262">    XMLEvent nextEvent = reader.peek();</span>

<span class="fc" id="L264">    boolean retval = nextEvent.isStartElement();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (retval) {</span>
<span class="fc" id="L266">      QName qname = ObjectUtils.notNull(nextEvent.asStartElement().getName());</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      retval = qname.equals(targetInstance.getEffectiveXmlGroupAsQName()) // parse the grouping element</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">          || targetInstance.canHandleXmlQName(qname); // parse the instance(s)</span>
    }
<span class="fc" id="L270">    return retval;</span>
  }

  /**
   * Read the data associated with the {@code instance} and apply it to the
   * provided {@code parentObject}.
   *
   * @param instance
   *          the instance to parse data for
   * @param parentObject
   *          the Java object that data parsed by this method will be stored in
   * @return {@code true} if the instance was parsed, or {@code false} if the data
   *         did not contain information for this instance
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  @Override
  public &lt;T&gt; boolean readItems(
      @NonNull IBoundInstanceModel&lt;T&gt; instance,
      @NonNull IBoundObject parentObject,
      boolean parseGrouping)
      throws IOException {
    try {
<span class="fc" id="L293">      boolean handled = isNextInstance(instance);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">      if (handled) {</span>
        // XmlEventUtil.skipWhitespace(reader);

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        QName groupQName = parseGrouping ? instance.getEffectiveXmlGroupAsQName() : null;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (groupQName != null) {</span>
          // we need to parse the grouping element, if the next token matches
<span class="fc" id="L300">          XmlEventUtil.requireStartElement(reader, groupQName);</span>
        }

<span class="fc" id="L303">        IModelInstanceCollectionInfo&lt;T&gt; collectionInfo = instance.getCollectionInfo();</span>

<span class="fc" id="L305">        ModelInstanceReadHandler&lt;T&gt; handler = new ModelInstanceReadHandler&lt;&gt;(instance, parentObject);</span>

        // let the property info decide how to parse the value
<span class="fc" id="L308">        Object value = collectionInfo.readItems(handler);</span>
<span class="fc" id="L309">        instance.setValue(parentObject, value);</span>

        // consume extra whitespace between elements
<span class="fc" id="L312">        XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (groupQName != null) {</span>
          // consume the end of the group
<span class="fc" id="L316">          XmlEventUtil.requireEndElement(reader, groupQName);</span>
        }
      }
<span class="fc" id="L319">      return handled;</span>
<span class="nc" id="L320">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L321">      throw new IOException(ex);</span>
    }
  }

<span class="fc" id="L325">  private final class ModelInstanceReadHandler&lt;ITEM&gt;</span>
      extends AbstractModelInstanceReadHandler&lt;ITEM&gt; {

    private ModelInstanceReadHandler(
        @NonNull IBoundInstanceModel&lt;ITEM&gt; instance,
<span class="fc" id="L330">        @NonNull IBoundObject parentObject) {</span>
<span class="fc" id="L331">      super(instance, parentObject);</span>
<span class="fc" id="L332">    }</span>

    @Override
    public List&lt;ITEM&gt; readList() throws IOException {
<span class="fc" id="L336">      return ObjectUtils.notNull(readCollection());</span>
    }

    @Override
    public Map&lt;String, ITEM&gt; readMap() throws IOException {
<span class="fc" id="L341">      IBoundInstanceModel&lt;?&gt; instance = getCollectionInfo().getInstance();</span>

<span class="fc" id="L343">      return ObjectUtils.notNull(readCollection().stream()</span>
<span class="fc" id="L344">          .collect(Collectors.toMap(</span>
              item -&gt; {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                assert item != null;</span>

<span class="fc" id="L348">                IBoundInstanceFlag jsonKey = instance.getItemJsonKey(item);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                assert jsonKey != null;</span>
<span class="fc" id="L350">                return ObjectUtils.requireNonNull(jsonKey.getValue(item)).toString();</span>
              },
<span class="fc" id="L352">              Function.identity(),</span>
<span class="nc" id="L353">              (t, u) -&gt; u,</span>
              LinkedHashMap::new)));
    }

    @NonNull
    private List&lt;ITEM&gt; readCollection() throws IOException {
<span class="fc" id="L359">      List&lt;ITEM&gt; retval = new LinkedList&lt;&gt;();</span>
      try {
        // consume extra whitespace between elements
<span class="fc" id="L362">        XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc" id="L364">        IBoundInstanceModel&lt;?&gt; instance = getCollectionInfo().getInstance();</span>
        XMLEvent event;
<span class="fc bfc" id="L366" title="All 2 branches covered.">        while ((event = reader.peek()).isStartElement()</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            &amp;&amp; instance.canHandleXmlQName(ObjectUtils.notNull(event.asStartElement().getName()))) {</span>

          // Consume the start element
<span class="fc" id="L370">          ITEM value = readItem();</span>
<span class="fc" id="L371">          retval.add(value);</span>

          // consume extra whitespace between elements
<span class="fc" id="L374">          XmlEventUtil.skipWhitespace(reader);</span>
<span class="fc" id="L375">        }</span>
<span class="nc" id="L376">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L377">        throw new IOException(ex);</span>
<span class="fc" id="L378">      }</span>
<span class="fc" id="L379">      return retval;</span>
    }

    @Override
    public ITEM readItem() throws IOException {
      try {
<span class="fc" id="L385">        return getCollectionInfo().getInstance().readItem(</span>
<span class="fc" id="L386">            getParentObject(),</span>
<span class="fc" id="L387">            new ItemReadHandler(ObjectUtils.notNull(getReader().peek().asStartElement())));</span>
<span class="nc" id="L388">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L389">        throw new IOException(ex);</span>
      }
    }
  }

<span class="fc" id="L394">  private final class ItemReadHandler implements IItemReadHandler {</span>
    @NonNull
    private final StartElement startElement;

<span class="fc" id="L398">    private ItemReadHandler(@NonNull StartElement startElement) {</span>
<span class="fc" id="L399">      this.startElement = startElement;</span>
<span class="fc" id="L400">    }</span>

    /**
     * Get the current start element.
     *
     * @return the startElement
     */
    @NonNull
    private StartElement getStartElement() {
<span class="fc" id="L409">      return startElement;</span>
    }

    @NonNull
    private &lt;DEF extends IBoundDefinitionModelComplex&gt; IBoundObject readDefinitionElement(
        @NonNull DEF definition,
        @NonNull StartElement start,
        @NonNull QName expectedQName,
        @Nullable IBoundObject parent,
        @NonNull DefinitionBodyHandler&lt;DEF, IBoundObject&gt; bodyHandler) throws IOException {
      try {
        // consume the start element
<span class="fc" id="L421">        XmlEventUtil.requireStartElement(reader, expectedQName);</span>

<span class="fc" id="L423">        Location location = start.getLocation();</span>

        // construct the item
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        IBoundObject item = definition.newInstance(location == null ? null : () -&gt; new MetaschemaData(location));</span>

        // call pre-parse initialization hook
<span class="fc" id="L429">        definition.callBeforeDeserialize(item, parent);</span>

        // read the flags
<span class="fc" id="L432">        readFlagInstances(definition, item, start);</span>

        // read the body
<span class="fc" id="L435">        bodyHandler.accept(definition, item);</span>

<span class="fc" id="L437">        XmlEventUtil.skipWhitespace(reader);</span>

        // call post-parse initialization hook
<span class="fc" id="L440">        definition.callAfterDeserialize(item, parent);</span>

        // consume the end element
<span class="fc" id="L443">        XmlEventUtil.requireEndElement(reader, expectedQName);</span>
<span class="fc" id="L444">        return ObjectUtils.asType(item);</span>
<span class="nc" id="L445">      } catch (BindingException | XMLStreamException ex) {</span>
<span class="nc" id="L446">        throw new IOException(ex);</span>
      }
    }

    @Override
    public Object readItemFlag(
        IBoundObject parent,
        IBoundInstanceFlag flag) throws IOException {
<span class="nc" id="L454">      throw new UnsupportedOperationException(&quot;handled by readFlagInstances()&quot;);</span>
    }

    private void handleFieldDefinitionBody(
        @NonNull IBoundDefinitionModelFieldComplex definition,
        @NonNull IBoundObject item) throws IOException {
<span class="fc" id="L460">      IBoundFieldValue fieldValue = definition.getFieldValue();</span>

      // parse the value
<span class="fc" id="L463">      Object value = fieldValue.readItem(item, this);</span>
<span class="fc" id="L464">      fieldValue.setValue(item, value);</span>
<span class="fc" id="L465">    }</span>

    @Override
    public Object readItemField(
        IBoundObject parent,
        IBoundInstanceModelFieldScalar instance)
        throws IOException {

      try {
<span class="fc" id="L474">        QName wrapper = null;</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (instance.isEffectiveValueWrappedInXml()) {</span>
<span class="fc" id="L476">          wrapper = instance.getXmlQName();</span>

<span class="fc" id="L478">          XmlEventUtil.skipWhitespace(getReader());</span>
<span class="fc" id="L479">          XmlEventUtil.requireStartElement(getReader(), wrapper);</span>
        }

<span class="fc" id="L482">        Object retval = readScalarItem(instance);</span>

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (wrapper != null) {</span>
<span class="fc" id="L485">          XmlEventUtil.skipWhitespace(getReader());</span>

<span class="fc" id="L487">          XmlEventUtil.requireEndElement(getReader(), wrapper);</span>
        }
<span class="fc" id="L489">        return retval;</span>
<span class="nc" id="L490">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L491">        throw new IOException(ex);</span>
      }
    }

    @Override
    public IBoundObject readItemField(
        IBoundObject parent,
        IBoundInstanceModelFieldComplex instance)
        throws IOException {
<span class="fc" id="L500">      return readDefinitionElement(</span>
<span class="fc" id="L501">          instance.getDefinition(),</span>
<span class="fc" id="L502">          getStartElement(),</span>
<span class="fc" id="L503">          instance.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public IBoundObject readItemField(IBoundObject parent, IBoundInstanceModelGroupedField instance)
        throws IOException {
<span class="nc" id="L511">      return readDefinitionElement(</span>
<span class="nc" id="L512">          instance.getDefinition(),</span>
<span class="nc" id="L513">          getStartElement(),</span>
<span class="nc" id="L514">          instance.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public IBoundObject readItemField(
        IBoundObject parent,
        IBoundDefinitionModelFieldComplex definition) throws IOException {
<span class="nc" id="L523">      return readDefinitionElement(</span>
          definition,
<span class="nc" id="L525">          getStartElement(),</span>
<span class="nc" id="L526">          definition.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public Object readItemFieldValue(
        IBoundObject parent,
        IBoundFieldValue fieldValue) throws IOException {
<span class="fc" id="L535">      return readScalarItem(fieldValue);</span>
    }

    private void handleAssemblyDefinitionBody(
        @NonNull IBoundDefinitionModelAssembly definition,
        @NonNull IBoundObject item) throws IOException {
<span class="fc" id="L541">      readModelInstances(definition, item);</span>
<span class="fc" id="L542">    }</span>

    @Override
    public IBoundObject readItemAssembly(
        IBoundObject parent,
        IBoundInstanceModelAssembly instance) throws IOException {
<span class="fc" id="L548">      return readDefinitionElement(</span>
<span class="fc" id="L549">          instance.getDefinition(),</span>
<span class="fc" id="L550">          getStartElement(),</span>
<span class="fc" id="L551">          instance.getXmlQName(),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @Override
    public IBoundObject readItemAssembly(IBoundObject parent, IBoundInstanceModelGroupedAssembly instance)
        throws IOException {
<span class="fc" id="L559">      return readDefinitionElement(</span>
<span class="fc" id="L560">          instance.getDefinition(),</span>
<span class="fc" id="L561">          getStartElement(),</span>
<span class="fc" id="L562">          instance.getXmlQName(),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @Override
    public IBoundObject readItemAssembly(
        IBoundObject parent,
        IBoundDefinitionModelAssembly definition) throws IOException {
<span class="fc" id="L571">      return readDefinitionElement(</span>
          definition,
<span class="fc" id="L573">          getStartElement(),</span>
<span class="fc" id="L574">          ObjectUtils.requireNonNull(definition.getRootXmlQName()),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @NonNull
    private Object readScalarItem(@NonNull IFeatureScalarItemValueHandler handler)
        throws IOException {
<span class="fc" id="L582">      return handler.getJavaTypeAdapter().parse(getReader());</span>
    }

    @Override
    public IBoundObject readChoiceGroupItem(IBoundObject parent, IBoundInstanceModelChoiceGroup instance)
        throws IOException {
      try {
<span class="fc" id="L589">        XMLEventReader2 eventReader = getReader();</span>
        // consume extra whitespace between elements
<span class="fc" id="L591">        XmlEventUtil.skipWhitespace(eventReader);</span>

<span class="fc" id="L593">        XMLEvent event = eventReader.peek();</span>
<span class="fc" id="L594">        QName nextQName = ObjectUtils.notNull(event.asStartElement().getName());</span>
<span class="fc" id="L595">        IBoundInstanceModelGroupedNamed actualInstance = instance.getGroupedModelInstance(nextQName);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        assert actualInstance != null;</span>
<span class="fc" id="L597">        return actualInstance.readItem(parent, this);</span>
<span class="nc" id="L598">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L599">        throw new IOException(ex);</span>
      }
    }
  }

  private static class MetaschemaData implements IMetaschemaData {
    private final int line;
    private final int column;
    private final long charOffset;

<span class="fc" id="L609">    public MetaschemaData(@NonNull Location location) {</span>
<span class="fc" id="L610">      this.line = location.getLineNumber();</span>
<span class="fc" id="L611">      this.column = location.getColumnNumber();</span>
<span class="fc" id="L612">      this.charOffset = location.getCharacterOffset();</span>
<span class="fc" id="L613">    }</span>

    @Override
    public int getLine() {
<span class="nc" id="L617">      return line;</span>
    }

    @Override
    public int getColumn() {
<span class="nc" id="L622">      return column;</span>
    }

    @Override
    public long getCharOffset() {
<span class="nc" id="L627">      return charOffset;</span>
    }

    @Override
    public long getByteOffset() {
<span class="nc" id="L632">      return -1;</span>
    }
  }

  @FunctionalInterface
  private interface DefinitionBodyHandler&lt;DEF extends IBoundDefinitionModelComplex, ITEM&gt; {
    void accept(
        @NonNull DEF definition,
        @NonNull ITEM item) throws IOException;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>