<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlObjectParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.xml.impl</a> &gt; <span class="el_source">XmlObjectParser.java</span></div><h1>XmlObjectParser.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.xml.impl;

import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.xmlbeans.XmlCursor;
import org.apache.xmlbeans.XmlCursor.XmlBookmark;
import org.apache.xmlbeans.XmlLineNumber;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.XmlOptions;

import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Supports parsing Metaschema assembly and field XMLBeans objects that contain
 * other Metaschema objects.
 *
 * @param &lt;T&gt;
 *          the Java type of the state that is passed to the element parsing
 *          handlers
 */
public class XmlObjectParser&lt;T&gt; {
<span class="fc" id="L37">  private static final XmlOptions XML_OPTIONS = new XmlOptions().setXPathUseSaxon(false).setXPathUseXmlBeans(true);</span>
  private final Map&lt;QName, Handler&lt;T&gt;&gt; elementNameToHandlerMap;
  private final String xpath;

  private static String generatePath(@NonNull Collection&lt;QName&gt; nodes) {
    // build a mapping of namespace prefix to namespace
<span class="fc" id="L43">    AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L44">    Map&lt;String, String&gt; namespaceToPrefixMap = nodes.stream()</span>
<span class="fc" id="L45">        .map(QName::getNamespaceURI)</span>
<span class="fc" id="L46">        .distinct()</span>
<span class="fc" id="L47">        .map(ns -&gt; Pair.of(ns, &quot;m&quot; + count.getAndIncrement()))</span>
<span class="fc" id="L48">        .collect(Collectors.toMap(</span>
            Pair::getKey,
            Pair::getValue,
<span class="nc" id="L51">            (k1, k2) -&gt; k1,</span>
            LinkedHashMap::new));

    // generate namespace declarations using prefix and namespace
<span class="fc" id="L55">    StringBuilder builder = new StringBuilder(24);</span>
<span class="fc" id="L56">    namespaceToPrefixMap.entrySet().forEach((entry) -&gt; {</span>
<span class="fc" id="L57">      builder.append(&quot;declare namespace &quot;)</span>
<span class="fc" id="L58">          .append(entry.getValue())</span>
<span class="fc" id="L59">          .append(&quot;='&quot;)</span>
<span class="fc" id="L60">          .append(entry.getKey())</span>
<span class="fc" id="L61">          .append(&quot;';&quot;);</span>
<span class="fc" id="L62">    });</span>

    // generate child path
<span class="fc" id="L65">    builder.append(nodes.stream()</span>
<span class="fc" id="L66">        .map(qname -&gt; {</span>
<span class="fc" id="L67">          return new StringBuilder()</span>
<span class="fc" id="L68">              .append(&quot;$this/&quot;)</span>
<span class="fc" id="L69">              .append(namespaceToPrefixMap.get(qname.getNamespaceURI()))</span>
<span class="fc" id="L70">              .append(':')</span>
<span class="fc" id="L71">              .append(qname.getLocalPart())</span>
<span class="fc" id="L72">              .toString();</span>
<span class="fc" id="L73">        }).collect(Collectors.joining(&quot;|&quot;)));</span>

<span class="fc" id="L75">    return builder.toString();</span>
  }

  /**
   * Construct a new XmlObject parser.
   *
   * @param elementNameToHandlerMap
   *          the mapping of element names to associated handlers
   */
<span class="fc" id="L84">  public XmlObjectParser(@NonNull Map&lt;QName, Handler&lt;T&gt;&gt; elementNameToHandlerMap) {</span>
<span class="fc" id="L85">    this.elementNameToHandlerMap = elementNameToHandlerMap;</span>
<span class="fc" id="L86">    this.xpath = generatePath(ObjectUtils.notNull(elementNameToHandlerMap.keySet()));</span>
<span class="fc" id="L87">  }</span>

  private Map&lt;QName, Handler&lt;T&gt;&gt; getElementNameToHandlerMap() {
<span class="fc" id="L90">    return elementNameToHandlerMap;</span>
  }

  private String getXpath() {
<span class="fc" id="L94">    return xpath;</span>
  }

  /**
   * Get the resource location of the provided object.
   *
   * @param obj
   *          the XMLBeans object to get the location for
   * @return the resource location or {@code null} if the location is not known
   */
  @SuppressWarnings({ &quot;resource&quot;, &quot;null&quot; })
  @Nullable
  public static String toLocation(@NonNull XmlObject obj) {
<span class="nc" id="L107">    return toLocation(obj.newCursor());</span>
  }

  /**
   * Get the resource location of the provided cursor.
   *
   * @param cursor
   *          the XMLBeans cursor to get the location for
   * @return the resource location or {@code null} if the location is not known
   */
  @Nullable
  public static String toLocation(@NonNull XmlCursor cursor) {
<span class="nc" id="L119">    String retval = null;</span>
<span class="nc" id="L120">    XmlBookmark bookmark = cursor.getBookmark(XmlLineNumber.class);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">    if (bookmark != null) {</span>
<span class="nc" id="L122">      StringBuilder locationBuilder = new StringBuilder();</span>
<span class="nc" id="L123">      XmlLineNumber lineNumber = (XmlLineNumber) bookmark;</span>

<span class="nc" id="L125">      String source = cursor.documentProperties().getSourceName();</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      if (source != null) {</span>
<span class="nc" id="L127">        locationBuilder.append(source)</span>
<span class="nc" id="L128">            .append(':');</span>
      }

<span class="nc" id="L131">      locationBuilder.append(lineNumber.getLine())</span>
<span class="nc" id="L132">          .append(':')</span>
<span class="nc" id="L133">          .append(lineNumber.getColumn());</span>

<span class="nc" id="L135">      retval = locationBuilder.toString();</span>
    }
<span class="nc" id="L137">    return retval;</span>
  }

  /**
   * Used to determine which parser {@link Handler} implementation to use to parse
   * the object.
   * &lt;p&gt;
   * Subclasses can override this method to implement a more efficient or advanced
   * detection method.
   *
   * @param cursor
   *          the current XmlCursor location
   * @param obj
   *          the strongly typed XmlObject at the current location
   * @return the identified handler
   * @throws IllegalStateException
   *           if a suitable handler cannot be identified
   */
  @NonNull
  protected Handler&lt;T&gt; identifyHandler(@NonNull XmlCursor cursor, @NonNull XmlObject obj) {
<span class="fc" id="L157">    QName qname = cursor.getName();</span>
<span class="fc" id="L158">    Handler&lt;T&gt; retval = getElementNameToHandlerMap().get(qname);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">    if (retval == null) {</span>
<span class="nc" id="L160">      String location = toLocation(cursor);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      if (location == null) {</span>
<span class="nc" id="L162">        location = &quot;&quot;;</span>
      } else {
<span class="nc" id="L164">        location = new StringBuilder()</span>
<span class="nc" id="L165">            .append(&quot; at location '&quot;)</span>
<span class="nc" id="L166">            .append(location)</span>
<span class="nc" id="L167">            .append('\'')</span>
<span class="nc" id="L168">            .toString();</span>
      }
<span class="nc" id="L170">      throw new IllegalStateException(String.format(&quot;Unhandled node '%s'%s.&quot;, qname, location));</span>
    }
<span class="fc" id="L172">    return retval;</span>
  }

  /**
   * Parse an XmlObject element tree using the configured child element handlers.
   *
   * @param xmlObject
   *          the XmlObject container to parse
   * @param state
   *          parsing state to pass to the handlers
   * @return the state
   */
  public T parse(@NonNull XmlObject xmlObject, T state) {
<span class="fc" id="L185">    try (XmlCursor cursor = xmlObject.newCursor()) {</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">      assert cursor != null;</span>
<span class="fc" id="L187">      cursor.selectPath(getXpath(), XML_OPTIONS);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      while (cursor.toNextSelection()) {</span>
<span class="fc" id="L189">        XmlObject obj = cursor.getObject();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        assert obj != null;</span>
<span class="fc" id="L191">        Handler&lt;T&gt; handler = identifyHandler(cursor, obj);</span>
<span class="fc" id="L192">        handler.handle(obj, state);</span>
<span class="fc" id="L193">      }</span>
    }
<span class="fc" id="L195">    return state;</span>
  }

  /**
   * Provides a common interface for element parsing handlers.
   *
   * @param &lt;T&gt;
   *          the Java type of the state that is passed to the element parsing
   *          handlers
   */
  @FunctionalInterface
  public interface Handler&lt;T&gt; {
    /**
     * Parse the provided {@code obj} using the provided {@code state}.
     *
     * @param obj
     *          the object to parse
     * @param state
     *          the state to use for parsing
     */
    void handle(@NonNull XmlObject obj, T state);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>