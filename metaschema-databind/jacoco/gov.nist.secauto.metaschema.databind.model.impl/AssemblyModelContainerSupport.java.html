<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AssemblyModelContainerSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.model.impl</a> &gt; <span class="el_source">AssemblyModelContainerSupport.java</span></div><h1>AssemblyModelContainerSupport.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.model.impl;

import gov.nist.secauto.metaschema.core.model.IChoiceInstance;
import gov.nist.secauto.metaschema.core.model.IContainerModelAssemblySupport;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModel;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelField;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelNamed;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.annotations.BoundField;
import gov.nist.secauto.metaschema.databind.model.annotations.Ignore;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

<span class="fc" id="L38">class AssemblyModelContainerSupport</span>
    implements IContainerModelAssemblySupport&lt;
        IBoundInstanceModel&lt;?&gt;,
        IBoundInstanceModelNamed&lt;?&gt;,
        IBoundInstanceModelField&lt;?&gt;,
        IBoundInstanceModelAssembly,
        IChoiceInstance,
        IBoundInstanceModelChoiceGroup&gt; {
  @NonNull
  private final List&lt;IBoundInstanceModel&lt;?&gt;&gt; modelInstances;
  @NonNull
  private final Map&lt;QName, IBoundInstanceModelNamed&lt;?&gt;&gt; namedModelInstances;
  @NonNull
  private final Map&lt;QName, IBoundInstanceModelField&lt;?&gt;&gt; fieldInstances;
  @NonNull
  private final Map&lt;QName, IBoundInstanceModelAssembly&gt; assemblyInstances;
  @NonNull
  private final Map&lt;String, IBoundInstanceModelChoiceGroup&gt; choiceGroupInstances;

  @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;)
  @SuppressFBWarnings(value = &quot;CT_CONSTRUCTOR_THROW&quot;, justification = &quot;Use of final fields&quot;)
  public AssemblyModelContainerSupport(
<span class="fc" id="L60">      @NonNull DefinitionAssembly containingDefinition) {</span>
<span class="fc" id="L61">    this.modelInstances = CollectionUtil.unmodifiableList(ObjectUtils.notNull(</span>
<span class="fc" id="L62">        getModelInstanceStream(containingDefinition, containingDefinition.getBoundClass())</span>
<span class="fc" id="L63">            .collect(Collectors.toUnmodifiableList())));</span>

<span class="fc" id="L65">    Map&lt;QName, IBoundInstanceModelNamed&lt;?&gt;&gt; namedModelInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L66">    Map&lt;QName, IBoundInstanceModelField&lt;?&gt;&gt; fieldInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L67">    Map&lt;QName, IBoundInstanceModelAssembly&gt; assemblyInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L68">    Map&lt;String, IBoundInstanceModelChoiceGroup&gt; choiceGroupInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    for (IBoundInstanceModel&lt;?&gt; instance : this.modelInstances) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">      if (instance instanceof IBoundInstanceModelNamed) {</span>
<span class="fc" id="L71">        IBoundInstanceModelNamed&lt;?&gt; named = (IBoundInstanceModelNamed&lt;?&gt;) instance;</span>
<span class="fc" id="L72">        QName key = named.getXmlQName();</span>
<span class="fc" id="L73">        namedModelInstances.put(key, named);</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (instance instanceof IBoundInstanceModelField) {</span>
<span class="fc" id="L76">          fieldInstances.put(key, (IBoundInstanceModelField&lt;?&gt;) named);</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        } else if (instance instanceof IBoundInstanceModelAssembly) {</span>
<span class="fc" id="L78">          assemblyInstances.put(key, (IBoundInstanceModelAssembly) named);</span>
        }
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">      } else if (instance instanceof IBoundInstanceModelChoiceGroup) {</span>
<span class="fc" id="L81">        IBoundInstanceModelChoiceGroup choiceGroup = (IBoundInstanceModelChoiceGroup) instance;</span>
<span class="fc" id="L82">        String key = ObjectUtils.requireNonNull(choiceGroup.getGroupAsName());</span>
<span class="fc" id="L83">        choiceGroupInstances.put(key, choiceGroup);</span>
      }
<span class="fc" id="L85">    }</span>

<span class="fc bfc" id="L87" title="All 2 branches covered.">    this.namedModelInstances = namedModelInstances.isEmpty()</span>
<span class="fc" id="L88">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L89">        : CollectionUtil.unmodifiableMap(namedModelInstances);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">    this.fieldInstances = fieldInstances.isEmpty()</span>
<span class="fc" id="L91">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L92">        : CollectionUtil.unmodifiableMap(fieldInstances);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    this.assemblyInstances = assemblyInstances.isEmpty()</span>
<span class="fc" id="L94">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L95">        : CollectionUtil.unmodifiableMap(assemblyInstances);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">    this.choiceGroupInstances = choiceGroupInstances.isEmpty()</span>
<span class="fc" id="L97">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L98">        : CollectionUtil.unmodifiableMap(choiceGroupInstances);</span>
<span class="fc" id="L99">  }</span>

  protected static IBoundInstanceModel&lt;?&gt; newBoundModelInstance(
      @NonNull Field field,
      @NonNull IBoundDefinitionModelAssembly definition) {
<span class="fc" id="L104">    IBoundInstanceModel&lt;?&gt; retval = null;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">    if (field.isAnnotationPresent(BoundAssembly.class)) {</span>
<span class="fc" id="L106">      retval = IBoundInstanceModelAssembly.newInstance(field, definition);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    } else if (field.isAnnotationPresent(BoundField.class)) {</span>
<span class="fc" id="L108">      retval = IBoundInstanceModelField.newInstance(field, definition);</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    } else if (field.isAnnotationPresent(BoundChoiceGroup.class)) {</span>
<span class="fc" id="L110">      retval = IBoundInstanceModelChoiceGroup.newInstance(field, definition);</span>
    }
<span class="fc" id="L112">    return retval;</span>
  }

  @NonNull
  protected static Stream&lt;IBoundInstanceModel&lt;?&gt;&gt; getModelInstanceStream(
      @NonNull IBoundDefinitionModelAssembly definition,
      @NonNull Class&lt;?&gt; clazz) {

    Stream&lt;IBoundInstanceModel&lt;?&gt;&gt; superInstances;
<span class="fc" id="L121">    Class&lt;?&gt; superClass = clazz.getSuperclass();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (superClass == null) {</span>
<span class="fc" id="L123">      superInstances = Stream.empty();</span>
    } else {
      // get instances from superclass
<span class="fc" id="L126">      superInstances = getModelInstanceStream(definition, superClass);</span>
    }

<span class="fc" id="L129">    return ObjectUtils.notNull(Stream.concat(superInstances, Arrays.stream(clazz.getDeclaredFields())</span>
        // skip this field, since it is ignored
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        .filter(field -&gt; !field.isAnnotationPresent(Ignore.class))</span>
        // skip fields that aren't a Module field or assembly instance
<span class="fc bfc" id="L133" title="All 2 branches covered.">        .filter(field -&gt; field.isAnnotationPresent(BoundField.class)</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            || field.isAnnotationPresent(BoundAssembly.class)</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            || field.isAnnotationPresent(BoundChoiceGroup.class))</span>
<span class="fc" id="L136">        .map(field -&gt; {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">          assert field != null;</span>

<span class="fc" id="L139">          IBoundInstanceModel&lt;?&gt; retval = newBoundModelInstance(field, definition);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">          if (retval == null) {</span>
<span class="nc" id="L141">            throw new IllegalStateException(</span>
<span class="nc" id="L142">                String.format(&quot;The field '%s' on class '%s' is not bound&quot;, field.getName(), clazz.getName()));</span>
          }
<span class="fc" id="L144">          return retval;</span>
        })
<span class="fc" id="L146">        .filter(Objects::nonNull)));</span>
  }

  @Override
  public Collection&lt;IBoundInstanceModel&lt;?&gt;&gt; getModelInstances() {
<span class="fc" id="L151">    return modelInstances;</span>
  }

  @Override
  public Map&lt;QName, IBoundInstanceModelNamed&lt;?&gt;&gt; getNamedModelInstanceMap() {
<span class="nc" id="L156">    return namedModelInstances;</span>
  }

  @Override
  public Map&lt;QName, IBoundInstanceModelField&lt;?&gt;&gt; getFieldInstanceMap() {
<span class="fc" id="L161">    return fieldInstances;</span>
  }

  @Override
  public Map&lt;QName, IBoundInstanceModelAssembly&gt; getAssemblyInstanceMap() {
<span class="fc" id="L166">    return assemblyInstances;</span>
  }

  @Override
  public List&lt;IChoiceInstance&gt; getChoiceInstances() {
    // not supported
<span class="nc" id="L172">    return CollectionUtil.emptyList();</span>
  }

  @Override
  public Map&lt;String, IBoundInstanceModelChoiceGroup&gt; getChoiceGroupInstanceMap() {
<span class="fc" id="L177">    return choiceGroupInstances;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>